# LCP v0.2 Specification (Draft)

## LCP v0.2 Overview

LCP is an application-layer protocol carried over Lightning’s existing transport.
It enables a **quote → pay → stream** flow using existing Lightning node capabilities (plugins / external processes).
LCP does not modify the BOLTs.

This document defines **LCP v0.2**.

Key changes (v0.2):

* **NOT backward compatible** with v0.1.
* Adds **chunked streaming** for large payloads (input and result).
* Payment is **single upfront payment per job** (one invoice per job).
* `lcp_manifest` exchange is **mandatory** before any job-scope messages.

LCP v0.2 uses BOLT #1 custom messages over a direct peer connection.

---

## 1. Goals

LCP v0.2 defines:

* A minimal P2P message set to negotiate a compute job
* Binding between payment (BOLT11 invoice) and job terms to prevent invoice swapping
* Streaming delivery of large **input** and **result** payloads using chunked messages
* Application-layer idempotency and replay resistance
* Provider capability advertisement at connection scope (`lcp_manifest`)

Non-goals:

* Forwarding via onion messages / blinded paths
* Atomic swap guarantees beyond invoice binding
* Multi-party orchestration

---

## 2. Conventions and terminology

The key words MUST, MUST NOT, SHOULD, SHOULD NOT, MAY are to be interpreted as described in RFC 2119.

* Requester: the node requesting a job
* Provider: the node executing a job and delivering the result
* Job: a compute task identified by `job_id` (32 bytes)
* Stream: a large payload transferred via `lcp_stream_*` messages
* Connection scope: information tied to a connection (not tied to a job)
* Job scope: information tied to a specific job

All additional fields are encoded only as TLV streams.

### 2.1 Protocol versioning

LCP versions are written as `vMAJOR.MINOR` (for example, v0.2).

The wire field `protocol_version` is a `u16` derived from the (major, minor) pair:

* `protocol_version = major*100 + minor`

Notes:

* This specification defines LCP v0.2, therefore `protocol_version = 2`.
* Patch-level revisions to this document (v0.2.x) do not change `protocol_version`.

---

## 3. Transport

### 3.1 Direct peer requirement

All LCP v0.2 messages are sent as BOLT #1 custom messages.

* The Requester and Provider MUST have an active Lightning peer connection.
* LCP MUST NOT define or require a new non-Lightning transport.

Operational note (non-normative):

* How the Requester learns the Provider's network address is out of scope.
  This spec assumes a known pubkey (and a reachable address).

### 3.2 Custom message type range

LCP v0.2 uses the following message type numbers (all ≥ 32768).

BOLT #1 compatibility (odd/even parity rules):

* All LCP message types MUST be odd.
  (Unknown odd messages are ignored; unknown even messages are fatal.)

Assignments:

* 42081: `lcp_manifest`
* 42083: `lcp_quote_request`
* 42085: `lcp_quote_response`
* 42087: `lcp_result` (terminal job completion)
* 42089: `lcp_stream_begin`
* 42091: `lcp_stream_chunk`
* 42093: `lcp_stream_end`
* 42095: `lcp_cancel`
* 42097: `lcp_error`

Receivers MUST ignore unknown TLVs.
Receivers MUST apply BOLT #1 odd/even parity rules to unknown custom message types.

---

## 4. TLV (envelope)

Each LCP message payload is a TLV stream called `tlvs`. Unknown TLVs MUST be ignored.

TLV stream encoding (MUST):

* Each TLV record is encoded as `bigsize(type)`, `bigsize(length)`, then `value` (same as BOLT TLV streams).
* Records MUST be sorted in ascending `type`.
* Duplicate records with the same `type` MUST NOT be included.

### 4.1 type: 1 (`protocol_version`)

* data: [`u16`:`protocol_version`]

Meaning:

* `protocol_version` MUST be included in every LCP message.
* In this specification (LCP v0.2), `protocol_version` is 2.

### 4.2 Job-scope envelope TLVs

The following TLVs are common to all job-scope LCP messages (everything except `lcp_manifest`) (MUST).

The sender MUST include `job_id`, `msg_id`, and `expiry`.

* type: 2 (`job_id`): [`32*byte`:`job_id`]
* type: 3 (`msg_id`): [`32*byte`:`msg_id`]
* type: 4 (`expiry`): [`tu64`:`expiry`]

Meaning:

* `job_id` MUST be unpredictable (generated by the Requester).
* `msg_id` MUST be unique within the replay window, per sender, per `job_id`,
  except for `lcp_stream_chunk` where `msg_id` is deterministic (§5.5.4).
* `expiry` is Unix epoch seconds. The receiver MUST ignore messages where `expiry < now`.

Replay / idempotency retention:

To avoid unbounded memory usage, receivers MUST bound how long they retain replay / pending state.

Define:

* `MAX_ENVELOPE_EXPIRY_WINDOW_SECONDS`: an implementation-defined constant (RECOMMENDED: 600).
* `effective_expiry = min(expiry, now + MAX_ENVELOPE_EXPIRY_WINDOW_SECONDS)`

Rules (MUST):

* The receiver MUST de-duplicate by (`job_id`, `msg_id`) at least until `effective_expiry`.
* If a duplicate (`job_id`, `msg_id`) is received before `effective_expiry`, it MUST be ignored.
* If `expiry > now + MAX_ENVELOPE_EXPIRY_WINDOW_SECONDS`, the receiver MUST either:
  * reject/ignore the message, or
  * process it but retain replay/pending state only until `effective_expiry` (clamp).

### 4.3 Encoding of `byte` TLVs

The LCP wire format is a TLV stream. Therefore, application-defined data is carried in the value of `byte` TLVs.

Normative rules:

* Any `byte` TLV explicitly specified as a UTF-8 string in this spec MUST be valid UTF-8.
* All other `byte` TLVs MUST be treated as application-defined opaque bytes.
  If the receiver cannot interpret them, it MAY ignore them.

### 4.4 List encodings (inside TLV values)

To represent multiple elements without repeating TLV types in the outer stream, this spec defines list encodings inside TLV values.

#### 4.4.1 `bigsize_list`

* data: `bigsize(count)` + `count` repetitions of `bigsize(value_i)`

#### 4.4.2 `string_list`

* data: `bigsize(count)` + `count` repetitions of (`bigsize(len_i)` + `len_i` bytes)
* Each element MUST be a UTF-8 string.

#### 4.4.3 `bytes_list`

* data: `bigsize(count)` + `count` repetitions of (`bigsize(len_i)` + `len_i` bytes)
* Each element MUST be treated as application-defined opaque bytes.

---

## 5. Messages

## 5.1 type: 42081 (`lcp_manifest`)

`lcp_manifest` is a **mandatory** connection-scope message in which each peer declares limits and (optionally) supported task templates.

* data: [`tlv_stream`:`tlvs`]

Constraints:

* `lcp_manifest` is connection-scope and MUST NOT include job-scope envelope TLVs (`job_id`, `msg_id`, `expiry`).
* Each side MUST send exactly one `lcp_manifest` per connection.
* No job-scope messages MUST be sent until **both** manifests have been received.

Message-specific TLVs:

### type: 11 (`max_payload_bytes`)

* data: [`tu32`:`max_payload_bytes`]

Meaning:

* Declares the maximum payload size (the BOLT custom message payload portion) that the sender can receive.
* The peer MUST NOT send subsequent messages whose payload exceeds the receiver's declared `max_payload_bytes`.
* Implementations SHOULD cap `max_payload_bytes` to roughly 1/4 of the BOLT #1 custom message maximum (`length=65535 bytes`), e.g. 16384 bytes.

### type: 14 (`max_stream_bytes`)

* data: [`tu64`:`max_stream_bytes`]

Meaning:

* Declares the maximum total decoded bytes the sender can receive for a single stream (`lcp_stream_begin` … `lcp_stream_end`).

### type: 15 (`max_job_bytes`)

* data: [`tu64`:`max_job_bytes`]

Meaning:

* Declares the maximum total decoded bytes the sender can receive across all streams in a job (input + result + any future streams).

### type: 16 (`max_inflight_jobs`) (optional)

* data: [`u16`:`max_inflight_jobs`]

Meaning:

* Declares the maximum concurrent active jobs the sender is willing to handle per connection.

### type: 12 (`supported_tasks`) (optional)

* data: [`byte`:`supported_tasks`] (`bytes_list`)

Meaning:

* `supported_tasks` enumerates the task templates that the Provider accepts in `lcp_quote_request`.
* Each element is a TLV stream called `task_tlvs`, corresponding to `lcp_quote_request`'s `task_kind` / `params`.
* The Requester SHOULD select a task template from this list when constructing `lcp_quote_request`.

`task_tlvs` (the element TLV stream):

* type: 20 (`task_kind`)

  * data: [`byte`:`task_kind`] (UTF-8 string)

* type: 22 (`params_template`)

  * data: [`byte`:`params_template`] (bytes depending on `task_kind`; `llm.chat` uses §5.2.1)

Matching against `lcp_quote_request` (recommended):

* If the Provider declares `supported_tasks`, and the received `lcp_quote_request` does not match at least one task template, the Provider SHOULD return `lcp_error(code=unsupported_task)`.
* Task template matching:
  * `task_kind` MUST match as a string.
  * `params` handling depends on `task_kind`. For `task_kind="llm.chat"`, §5.2.1 MUST be followed.

---

## 5.2 type: 42083 (`lcp_quote_request`)

Starts a job negotiation and declares `task_kind` and optional parameters.

Input is NOT carried inline in v0.2. The Requester MUST send an input stream after the `lcp_quote_request` (§5.5).

* data: [`tlv_stream`:`tlvs`]

Required TLVs (minimum):

* type: 20 (`task_kind`): [`byte`:`task_kind`] (UTF-8 string, e.g., `llm.chat`)

Optional TLVs:

* type: 22 (`params`): [`byte`:`params`] (bytes depending on `task_kind`; `llm.chat` uses §5.2.1)

Meaning:

* The Provider MAY reject unsupported tasks via `lcp_error`.
* For `task_kind="llm.chat"`, the sender MUST follow the encoding rules in §5.2.1.
* If the Provider declares `lcp_manifest.supported_tasks`, the Requester SHOULD choose matching `task_kind` / `params`.

Input requirement (MUST):

* After sending `lcp_quote_request`, the Requester MUST send exactly one input stream with `stream_kind=input` (§5.5.1).
* The Provider MUST NOT send `lcp_quote_response` until it has received and validated the input stream.

Idempotency (recommended):

* If the Provider receives multiple `lcp_quote_request` messages for the same `job_id`, it SHOULD return the same `lcp_quote_response` (if still valid) or SHOULD return an `lcp_error` indicating `quote_expired`.

---

### 5.2.1 Default `task_kind` (v0.2)

LCP v0.2 standardizes at least the following `task_kind` values:

#### `task_kind = "llm.chat"`

Input stream interpretation:

* The decoded input stream bytes MUST be a UTF-8 prompt string.

`params` encoding:

* `params` MUST be a TLV stream called `llm_chat_params_tlvs`.
* The TLV encoding for `llm_chat_params_tlvs` is the same as the TLV stream in §4.
* `llm_chat_params_tlvs` MUST include at least `profile`.

`llm_chat_params_tlvs` (standard TLVs):

* type: 1 (`profile`): [`byte`:`profile`] (UTF-8 string)
  Meaning:
  * `profile` MUST identify the execution target.
  * It MAY represent more than a model name (for example routing or a deployment unit).
* type: 2 (`temperature_milli`): [`tu32`:`temperature_milli`] (e.g., 700 means 0.7)
* type: 3 (`max_output_tokens`): [`tu32`:`max_output_tokens`]

Constraint (recommended):

* Providers SHOULD reject `llm_chat_params_tlvs` containing unknown param types with `lcp_error(code=unsupported_params)`.

Result:

* The decoded result stream bytes MUST be a UTF-8 string.

Extensions:

* Implementations MAY support additional `task_kind` values beyond the above.
* If the parties have not pre-agreed on the encoding of `input` / `params`, the Provider SHOULD return `lcp_error` with `unsupported_task`.

---

## 5.3 type: 42085 (`lcp_quote_response`)

Provides a price and a BOLT11 invoice bound to the job terms.

* data: [`tlv_stream`:`tlvs`]

Required TLVs:

* type: 30 (`price_msat`): [`tu64`:`price_msat`]
* type: 31 (`quote_expiry`): [`tu64`:`quote_expiry`]
* type: 32 (`terms_hash`): [`32*byte`:`terms_hash`]
* type: 33 (`payment_request`): [`byte`:`payment_request`] (BOLT11 invoice string, UTF-8)

Invoice binding (MUST):

* The Provider MUST set the BOLT11 invoice `description_hash` to exactly equal `terms_hash`.
* Before paying, the Requester MUST verify:
  * `description_hash == terms_hash`
  * the invoice payee (destination node pubkey) matches the LCP peer's (Provider's) pubkey
  * the invoice amount equals `price_msat` (amount-less invoices MUST be rejected)
  * the invoice expiry time does not exceed `quote_expiry`

Invoice time rules (MUST):

* Let `invoice_timestamp_unix` be the BOLT11 invoice timestamp (Unix epoch seconds).
* Let `invoice_expiry_seconds` be the BOLT11 invoice expiry (seconds).
* Define `invoice_expiry_unix = invoice_timestamp_unix + invoice_expiry_seconds`.
* The Requester MUST verify `invoice_expiry_unix <= quote_expiry`.
  * Implementations MAY include a small allowance for clock skew (RECOMMENDED: `ALLOWED_CLOCK_SKEW_SECONDS = 5`).

Execution rule (MUST):

* The Provider MUST NOT start executing or delivering results for `job_id` until the invoice is settled.

`terms_hash` computation (MUST):

* `terms_hash = SHA256(tlv_encode(terms_tlvs))`
* `terms_tlvs` is a canonical TLV stream containing only:
  * type: 1 (`protocol_version`): `u16`
  * type: 2 (`job_id`): `32*byte`
  * type: 3 (`price_msat`): `tu64`
  * type: 4 (`quote_expiry`): `tu64`
  * type: 20 (`task_kind`): UTF-8 string
  * type: 50 (`input_hash`): `32*byte` (`SHA256(input_decoded_bytes)`)
  * type: 52 (`input_len`): `tu64` (byte length of `input_decoded_bytes`)
  * type: 53 (`input_content_type`): UTF-8 string
  * type: 54 (`input_content_encoding`): UTF-8 string
  * type: 51 (`params_hash`): `32*byte` (`SHA256(canonical_tlv(params))`)

`canonical_tlv(params)` (MUST):

* If `params` is present, it MUST be interpreted as a TLV stream.
* The receiver MUST compute `params_hash` by:
  1. decoding the TLV stream (`params`) and rejecting invalid TLV encodings
  2. re-encoding it in canonical TLV stream form (ascending type, no duplicates)
  3. hashing the canonical re-encoding with SHA256
* If `params` is absent, `params_hash = SHA256(empty)` (empty byte string).

Input binding source (MUST):

* The Provider MUST compute (`input_hash`, `input_len`, `input_content_type`, `input_content_encoding`)
  from the validated input stream (§5.5). If the input stream cannot be validated, the Provider MUST NOT issue a quote.

---

## 5.4 type: 42087 (`lcp_result`)

Terminal job completion message.

* data: [`tlv_stream`:`tlvs`]

Required TLVs:

* type: 100 (`status`): [`u16`:`status`]
  * 0: `ok`
  * 1: `failed`
  * 2: `cancelled`

If `status = ok`, required additional TLVs:

* type: 101 (`result_stream_id`): [`32*byte`:`result_stream_id`]
* type: 102 (`result_hash`): [`32*byte`:`result_hash`] (`SHA256(result_decoded_bytes)`)
* type: 103 (`result_len`): [`tu64`:`result_len`] (byte length of `result_decoded_bytes`)
* type: 104 (`result_content_type`): [`byte`:`result_content_type`] (UTF-8 string)
* type: 105 (`result_content_encoding`): [`byte`:`result_content_encoding`] (UTF-8 string)

If `status != ok`, optional TLVs:

* type: 81 (`message`): [`byte`:`message`] (UTF-8 string)

Meaning:

* If `status=ok`, the Provider MUST have sent exactly one validated result stream (§5.5) matching the metadata in this message.
* After receiving `lcp_result`, the Requester SHOULD treat the job as terminal and stop accepting further job-scope messages for that `job_id` (except duplicates within the replay window).

---

## 5.5 Stream transfer (chunking)

Streams are used for large payloads (input and result) and are carried with:

* `lcp_stream_begin` (42089)
* `lcp_stream_chunk` (42091)
* `lcp_stream_end` (42093)

### 5.5.1 Stream kinds

Stream kinds:

* 1: `input`
* 2: `result`

Constraints (v0.2):

* Exactly one input stream MUST be sent by the Requester after `lcp_quote_request` and before `lcp_quote_response`.
* Exactly one result stream MUST be sent by the Provider after invoice settlement and before `lcp_result(status=ok)`.

Receivers MUST reject any additional streams of the same kind for a job with `lcp_error(code=invalid_state)`.

### 5.5.2 Content type / encoding

`content_type`:

* A UTF-8 media type string (for example, `text/plain; charset=utf-8`).

`content_encoding`:

* A UTF-8 identifier describing how stream chunk bytes are decoded into the logical stream bytes.

This specification defines:

* `identity`: chunk bytes are the decoded bytes (MUST be supported)

Receivers MUST reject unknown `content_encoding` with `lcp_error(code=unsupported_encoding)`.

Unless explicitly stated otherwise, all `sha256` and `total_len` fields refer to the decoded stream bytes.

### 5.5.3 type: 42089 (`lcp_stream_begin`)

* data: [`tlv_stream`:`tlvs`]

Required TLVs:

* type: 90 (`stream_id`): [`32*byte`:`stream_id`]
* type: 91 (`stream_kind`): [`u16`:`stream_kind`]
* type: 94 (`content_type`): [`byte`:`content_type`] (UTF-8 string)
* type: 95 (`content_encoding`): [`byte`:`content_encoding`] (UTF-8 string)

Input stream requirements (`stream_kind = input`) (MUST):

* type: 92 (`total_len`): [`tu64`:`total_len`]
* type: 93 (`sha256`): [`32*byte`:`sha256`]

Result stream (`stream_kind = result`):

* `total_len` and `sha256` MAY be omitted if unknown at start.
  (They MUST be provided in `lcp_stream_end`.)

Limit enforcement (MUST):

* The receiver MUST enforce `total_len <= max_stream_bytes` (from the sender's `lcp_manifest`) if `total_len` is present.
* The receiver MUST enforce that total decoded bytes received do not exceed `max_stream_bytes` even if `total_len` was omitted.
* The receiver MUST enforce that total decoded bytes across all streams in the job do not exceed `max_job_bytes`.

### 5.5.4 type: 42091 (`lcp_stream_chunk`)

* data: [`tlv_stream`:`tlvs`]

Required TLVs:

* type: 90 (`stream_id`): [`32*byte`:`stream_id`]
* type: 96 (`seq`): [`tu32`:`seq`] (0,1,2,…)
* type: 97 (`data`): [`byte`:`data`] (chunk payload)

Chunk ordering rules (MUST):

* `seq` MUST start at 0 and increase by exactly 1 for each subsequent accepted chunk.
* If `seq < expected_seq`, the receiver MUST treat the chunk as a duplicate and MUST ignore it.
* If `seq > expected_seq`, the receiver MUST reject with `lcp_error(code=chunk_out_of_order)`.

Deterministic `msg_id` (MUST):

To keep replay state bounded, `lcp_stream_chunk` MUST set:

* `msg_id = SHA256(stream_id || u32be(seq))` (32 bytes)

Where `u32be(seq)` is `seq` encoded as a 4-byte big-endian unsigned integer.

Size rule (MUST):

* The sender MUST ensure each `lcp_stream_chunk` message payload size does not exceed the peer's `max_payload_bytes`.
* The sender SHOULD choose `len(data)` such that the full message fits within `max_payload_bytes` after TLV overhead.

### 5.5.5 type: 42093 (`lcp_stream_end`)

* data: [`tlv_stream`:`tlvs`]

Required TLVs:

* type: 90 (`stream_id`): [`32*byte`:`stream_id`]
* type: 92 (`total_len`): [`tu64`:`total_len`]
* type: 93 (`sha256`): [`32*byte`:`sha256`]

Validation (MUST):

* The receiver MUST verify:
  * total decoded bytes length equals `total_len`
  * `SHA256(decoded_bytes) == sha256`
* If validation fails, the receiver MUST send `lcp_error(code=checksum_mismatch)` and SHOULD treat the job as failed.

---

## 5.6 type: 42095 (`lcp_cancel`)

* data: [`tlv_stream`:`tlvs`]

Optional TLVs:

* type: 70 (`reason`): [`byte`:`reason`] (UTF-8 string)

Meaning:

* On receiving `lcp_cancel`, the receiver SHOULD stop further work for `job_id` best-effort.
* If cancellation occurs after payment, refunds are out of scope.

---

## 5.7 type: 42097 (`lcp_error`)

Protocol-level terminal error.

* data: [`tlv_stream`:`tlvs`]

Required TLVs:

* type: 80 (`code`): [`u16`:`code`]

Optional TLVs:

* type: 81 (`message`): [`byte`:`message`] (UTF-8 string)

Recommended error codes:

* 1: `unsupported_version`
* 2: `unsupported_task`
* 3: `quote_expired`
* 4: `payment_required`
* 5: `payment_invalid`
* 6: `payload_too_large`
* 7: `rate_limited`
* 8: `unsupported_params`
* 9: `unsupported_encoding`
* 10: `invalid_state`
* 11: `chunk_out_of_order`
* 12: `checksum_mismatch`

Note:

* `message` is human-readable supplemental information. Receivers MAY display it.

---

## 6. Minimal state machine

### 6.1 Requester

1. Connect to the Provider (out of scope).
2. Exchange `lcp_manifest` (MUST).
3. Send `lcp_quote_request`.
4. Send input stream:
   1. `lcp_stream_begin(stream_kind=input, total_len, sha256, content_type, content_encoding)`
   2. `lcp_stream_chunk` × N
   3. `lcp_stream_end(total_len, sha256)`
5. Receive `lcp_quote_response`. Verify invoice binding and payee. Pay the invoice.
6. Receive result stream:
   1. `lcp_stream_begin(stream_kind=result, …)`
   2. `lcp_stream_chunk` × N
   3. `lcp_stream_end(total_len, sha256)`
7. Receive `lcp_result`.

### 6.2 Provider

1. Exchange `lcp_manifest` (MUST).
2. Receive `lcp_quote_request`.
3. Receive and validate input stream.
4. Send `lcp_quote_response` with an invoice bound to terms.
5. Wait for invoice settlement.
6. Execute job.
7. Send result stream.
8. Send `lcp_result`.
9. If `lcp_cancel` is received, stop work best-effort.

---

## 7. Security considerations

### 7.1 Replay protection

Receivers MUST de-duplicate by (`job_id`, `msg_id`) at least until `effective_expiry` (see §4.2).

For `lcp_stream_chunk`, `msg_id` is deterministic (§5.5.4) and stream reassembly state can be used to keep memory bounded.

### 7.2 DoS resistance

* Implementations MUST enforce payload size limits and stream/job limits via:
  * `lcp_manifest.max_payload_bytes`
  * `lcp_manifest.max_stream_bytes`
  * `lcp_manifest.max_job_bytes`
* Implementations SHOULD enforce per-peer rate limits.
* Providers MAY restrict who they serve (for example pubkey allowlists, or peers with existing channels).
* Providers MAY return `rate_limited`.

### 7.3 Preventing invoice swapping

The Requester MUST satisfy at least:

* `description_hash == terms_hash`
* the invoice payee (destination node pubkey) matches the LCP peer's (Provider's) pubkey

This detects paying an invoice for a different node.

---

## 8. Trade-offs and limitations (direct peer connections)

LCP v0.2 makes the following trade-offs explicit:

* Direct connections. Privacy is not fully preserved compared to onion messages or blinded paths.
* Payment happens before execution. This is not a perfect atomic swap.
* Large payloads are supported via streaming, but are still subject to peer-declared limits.
* Provider receives full input stream before quoting, which increases pre-payment bandwidth exposure (bounded by manifest limits).

This specification does not define forwarding via onion messages or blinded paths.

