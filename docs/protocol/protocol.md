# LCP v0.1 Specification

## LCP v0.1 Overview

LCP is an application-layer protocol carried over Lightning's existing transport.
It enables a quote → pay → result flow using existing Lightning node capabilities (plugins / external processes).
LCP does not modify the BOLTs.

This document defines LCP v0.1.
It uses BOLT #1 custom messages over a direct peer connection.

LCP v0.1 treats application-defined byte payloads as `byte` TLVs and standardizes a minimal encoding for `llm.chat` (§4.4, §5.2.1).

---

## 1. Goals

LCP v0.1 defines:

* A minimal P2P message set to negotiate a compute job
* Binding between payment (BOLT11 invoice) and job terms to prevent invoice swapping
* Result delivery in a single message
* Application-layer idempotency and replay resistance
* A way for a Provider to declare accepted task templates (`task_kind` + `params`) at connection scope

---

## 2. Conventions and terminology

The key words MUST, MUST NOT, SHOULD, SHOULD NOT, MAY are to be interpreted as described in RFC 2119.

* Requester: the node requesting a job
* Provider: the node executing the job and delivering the result
* Job: a compute task identified by `job_id` (32 bytes)
* Connection scope: information tied to a connection (not tied to a job)
* Job scope: information tied to a specific job

All additional fields are encoded only as TLV streams.

### 2.1 Protocol versioning

LCP versions are written as `vMAJOR.MINOR` (for example, v0.1).

The wire field `protocol_version` is a `u16` derived from the (major, minor) pair:

* `protocol_version = major*100 + minor`

Notes:

* This specification defines LCP v0.1, therefore `protocol_version = 1`.
* Patch-level revisions to this document (v0.1.x) do not change `protocol_version`.

---

## 3. Transport

### 3.1 Direct peer requirement

All LCP v0.1 messages are sent as BOLT #1 custom messages.

* The Requester and Provider MUST have an active Lightning peer connection.
* LCP MUST NOT define or require a new non-Lightning transport.

Operational note (non-normative):

* How the Requester learns the Provider's network address is out of scope.
  This spec assumes a known pubkey (and a reachable address).

### 3.2 Custom message type range

LCP v0.1 uses the following message type numbers (all ≥ 32768).

BOLT #1 compatibility (odd/even parity rules):

* All LCP message types MUST be odd.
  (Unknown odd messages are ignored; unknown even messages are fatal.)

Assignments:

* 42081: `lcp_manifest`
* 42083: `lcp_quote_request`
* 42085: `lcp_quote_response`
* 42087: `lcp_result`
* 42095: `lcp_cancel`
* 42097: `lcp_error`

Receivers MUST ignore unknown TLVs.
Receivers MUST apply BOLT #1 odd/even parity rules to unknown custom message types.

---

## 4. TLV (envelope)

Each LCP message payload is a TLV stream called `tlvs`. Unknown TLVs MUST be ignored.

TLV stream encoding (MUST):

* Each TLV record is encoded as `bigsize(type)`, `bigsize(length)`, then `value` (same as BOLT TLV streams).
* Records MUST be sorted in ascending `type`.
* Duplicate records with the same `type` MUST NOT be included.

### 4.1 type: 1 (`protocol_version`)

* data: [`u16`:`protocol_version`]

Meaning:

* `protocol_version` MUST be included in every LCP message.
* In this specification (LCP v0.1), `protocol_version` is 1.
  (See §2.1 for the `protocol_version` encoding rule.)

### 4.2 Job-scope envelope TLVs

The following TLVs are common to all job-scope LCP messages (everything except `lcp_manifest`) (MUST).

The sender MUST include `job_id`, `msg_id`, and `expiry`.

* type: 2 (`job_id`): [`32*byte`:`job_id`]
* type: 3 (`msg_id`): [`32*byte`:`msg_id`]
* type: 4 (`expiry`): [`tu64`:`expiry`]

Meaning:

* `job_id` MUST be unpredictable (generated by the Requester).
* `msg_id` MUST be unique within the replay window, per sender, per `job_id`.
* `expiry` is Unix epoch seconds. The receiver MUST ignore messages where `expiry < now`.

Replay / idempotency:

To avoid unbounded memory usage, receivers MUST bound how long they retain replay / pending state.

Define:

* `MAX_ENVELOPE_EXPIRY_WINDOW_SECONDS`: an implementation-defined constant (RECOMMENDED: 600).
* `effective_expiry = min(expiry, now + MAX_ENVELOPE_EXPIRY_WINDOW_SECONDS)`

Rules (MUST):

* The receiver MUST de-duplicate by (`job_id`, `msg_id`) at least until `effective_expiry`.
* If a duplicate (`job_id`, `msg_id`) is received before `effective_expiry`, it MUST be ignored.
* If `expiry > now + MAX_ENVELOPE_EXPIRY_WINDOW_SECONDS`, the receiver MUST either:
  * reject/ignore the message, or
  * process it but retain replay/pending state only until `effective_expiry` (clamp).

### 4.3 Encoding of `byte` TLVs

The LCP wire format is a TLV stream. Therefore, application-defined data is carried in the value of `byte` TLVs.

Normative rules:

* Any `byte` TLV explicitly specified as a UTF-8 string in this spec (e.g., `task_kind`, `payment_request`, `content_type`, `reason`, `message`) MUST be valid UTF-8.
* All other `byte` TLVs MUST be treated as application-defined opaque bytes.
  If the receiver cannot interpret them, it MAY ignore them.

### 4.4 List encodings (inside TLV values)

To represent multiple elements without repeating TLV types in the outer stream, this spec defines list encodings inside TLV values.

#### 4.4.1 `bigsize_list`

* data: `bigsize(count)` + `count` repetitions of `bigsize(value_i)`

#### 4.4.2 `string_list`

* data: `bigsize(count)` + `count` repetitions of (`bigsize(len_i)` + `len_i` bytes)
* Each element MUST be a UTF-8 string.

#### 4.4.3 `bytes_list`

* data: `bigsize(count)` + `count` repetitions of (`bigsize(len_i)` + `len_i` bytes)
* Each element MUST be treated as application-defined opaque bytes.

---

## 5. Messages

## 5.1 type: 42081 (`lcp_manifest`)

`lcp_manifest` is a connection-scope message in which a Provider (and optionally a Requester) declares what it offers.

In particular, it can enumerate accepted `task_kind` + `params` combinations (task templates) for `lcp_quote_request`.

* data: [`tlv_stream`:`tlvs`]

Constraints:

* `lcp_manifest` is connection-scope and MUST NOT include job-scope envelope TLVs (`job_id`, `msg_id`, `expiry`).
* If an implementation receives `lcp_manifest`, it SHOULD respond with its own `lcp_manifest` on the same connection.
* To avoid infinite loops, an implementation MUST send `lcp_manifest` at most once per connection
  (either proactively on connect, or as a response to receiving one).

Message-specific TLVs:

### type: 11 (`max_payload_bytes`)

* data: [`tu32`:`max_payload_bytes`]

Meaning:

* Declares the maximum payload size (the BOLT custom message payload portion) that the sender can receive.
* The peer MUST NOT send subsequent messages whose payload exceeds the receiver's declared `max_payload_bytes`.
* Implementations SHOULD cap `max_payload_bytes` to roughly 1/4 of the BOLT #1 custom message maximum (`length=65535 bytes`), e.g. 16384 bytes.

---

### type: 12 (`supported_tasks`)

* data: [`byte`:`supported_tasks`] (`bytes_list`)

Meaning:

* `supported_tasks` enumerates the task templates that the Provider accepts in `lcp_quote_request`.
* Each element is a TLV stream called `task_tlvs`, corresponding to `lcp_quote_request`'s `task_kind` / `params`.
* The Requester SHOULD select a task template from this list when constructing `lcp_quote_request`.

`task_tlvs` (the element TLV stream):

* type: 20 (`task_kind`)

  * data: [`byte`:`task_kind`] (UTF-8 string)

* type: 22 (`params`)

  * data: [`byte`:`params`] (bytes depending on `task_kind`; `llm.chat` uses §5.2.1)

Matching against `lcp_quote_request` (normative):

* If the Provider declares `supported_tasks`, and the received `lcp_quote_request` does not match at least one task template, the Provider SHOULD return `lcp_error(code=unsupported_task)`.
* Task template matching:

  * `task_kind` MUST match as a string.
  * `params` handling depends on `task_kind`. For `task_kind="llm.chat"`, §5.2.1 MUST be followed.

## 5.2 type: 42083 (`lcp_quote_request`)

* data: [`tlv_stream`:`tlvs`]

Required TLVs (minimum):

* type: 20 (`task_kind`): [`byte`:`task_kind`] (UTF-8 string, e.g., `llm.chat`)
* type: 21 (`input`): [`byte`:`input`] (bytes depending on `task_kind`; `llm.chat` uses §5.2.1)

Optional TLVs:

* type: 22 (`params`): [`byte`:`params`] (bytes depending on `task_kind`; `llm.chat` uses §5.2.1)

Meaning:

* The Provider MAY reject unsupported tasks via `lcp_error`.
* For `task_kind="llm.chat"`, the sender MUST follow the encoding rules in §5.2.1.
* If the Provider declares `lcp_manifest.supported_tasks`, the Requester SHOULD choose matching `task_kind` / `params`.

Idempotency:

* If the Provider receives multiple `lcp_quote_request` messages for the same `job_id`, it SHOULD return the same `lcp_quote_response` (if still valid) or SHOULD return an `lcp_error` indicating `quote_expired`.

---

### 5.2.1 Default `task_kind` (v0.1)

LCP v0.1 standardizes at least the following `task_kind` values:

#### `task_kind = "llm.chat"`

* `input` MUST be a UTF-8 prompt string.

* `params` MUST be a TLV stream called `llm_chat_params_tlvs`.
* The TLV encoding for `llm_chat_params_tlvs` is the same as the TLV stream in §4.
* `llm_chat_params_tlvs` MUST include at least `profile`.

`llm_chat_params_tlvs` (standard TLVs):

* type: 1 (`profile`): [`byte`:`profile`] (UTF-8 string)
  Meaning:
  * `profile` MUST identify the execution target.
  * It MAY represent more than a model name (for example routing or a deployment unit).
  * If the Provider declares `lcp_manifest.supported_tasks`, the Requester SHOULD prefer a profile consistent with an advertised `task_kind="llm.chat"` template.
* type: 2 (`temperature_milli`): [`tu32`:`temperature_milli`] (e.g., 700 means 0.7)
* type: 3 (`max_output_tokens`): [`tu32`:`max_output_tokens`]

Constraint (recommended):

* Providers SHOULD reject `llm_chat_params_tlvs` containing unknown param types with `lcp_error(code=unsupported_params)`.

Matching against `lcp_manifest.supported_tasks` (recommended):

* If the Provider declares `supported_tasks`, a `task_kind="llm.chat"` `lcp_quote_request` SHOULD match at least one task template.
* `llm.chat` matching requires:

  * `task_kind` matches.
  * `lcp_quote_request.params` (=`llm_chat_params_tlvs`) MUST include all TLVs (type and value) present in the template's `params`.

Result:

* `lcp_result.result` (`result_bytes`) MUST be a UTF-8 string.

Extensions:

* Implementations MAY support additional `task_kind` values beyond the above.
* If the parties have not pre-agreed on the encoding of `input` / `params`, the Provider SHOULD return `lcp_error` with `unsupported_task`.

---

## 5.3 type: 42085 (`lcp_quote_response`)

* data: [`tlv_stream`:`tlvs`]

Required TLVs:

* type: 30 (`price_msat`): [`tu64`:`price_msat`]
* type: 31 (`quote_expiry`): [`tu64`:`quote_expiry`]
* type: 32 (`terms_hash`): [`32*byte`:`terms_hash`]
* type: 33 (`payment_request`): [`byte`:`payment_request`] (BOLT11 invoice string, UTF-8)

Invoice binding (MUST):

* The Provider MUST set the BOLT11 invoice `description_hash` to exactly equal `terms_hash`.
* Before paying, the Requester MUST verify:
  * `description_hash == terms_hash`
  * the invoice payee (destination node pubkey) matches the LCP peer's (Provider's) pubkey
  * the invoice amount equals `price_msat` (amount-less invoices MUST be rejected)
  * the invoice expiry time does not exceed `quote_expiry`

Invoice time rules (MUST):

* Let `invoice_timestamp_unix` be the BOLT11 invoice timestamp (Unix epoch seconds).
* Let `invoice_expiry_seconds` be the BOLT11 invoice expiry (seconds).
* Define `invoice_expiry_unix = invoice_timestamp_unix + invoice_expiry_seconds`.
* The Requester MUST verify `invoice_expiry_unix <= quote_expiry`.
  * Implementations MAY include a small allowance for clock skew (RECOMMENDED: `ALLOWED_CLOCK_SKEW_SECONDS = 5`).

`terms_hash` computation (MUST):

* `terms_hash = SHA256(tlv_encode(terms_tlvs))`
* `terms_tlvs` is a canonical TLV stream containing only:
  * type: 1 (`protocol_version`): `u16`
  * type: 2 (`job_id`): `32*byte`
  * type: 3 (`price_msat`): `tu64`
  * type: 4 (`quote_expiry`): `tu64`
  * type: 20 (`task_kind`): UTF-8 string
  * type: 50 (`input_hash`): `32*byte` (`SHA256(input)`)
  * type: 51 (`params_hash`): `32*byte` (`SHA256(canonical_tlv(params))`)

`canonical_tlv(params)` (MUST):

* If `params` is present, it MUST be interpreted as a TLV stream.
* The receiver MUST compute `params_hash` by:
  1. decoding the TLV stream (`params`) and rejecting invalid TLV encodings
  2. re-encoding it in canonical TLV stream form (ascending type, no duplicates)
  3. hashing the canonical re-encoding with SHA256
* If `params` is absent, `params_hash = SHA256(empty)` (empty byte string).

Execution rule:

* The Provider MUST NOT start executing or delivering results for `job_id` until the invoice is settled.

---

## 5.4 type: 42087 (`lcp_result`)

* data: [`tlv_stream`:`tlvs`]

Required TLVs:

* type: 40 (`result`): [`byte`:`result`] (result bytes, `result_bytes`)

Optional TLVs:

* type: 41 (`content_type`): [`byte`:`content_type`] (UTF-8 string, e.g., `text/plain; charset=utf-8`, `application/octet-stream`)

Meaning:

* If `content_type` is present, it indicates the media type of `result_bytes`.
* For `task_kind="llm.chat"`, the Provider SHOULD set `content_type="text/plain; charset=utf-8"`.
  The Requester SHOULD treat `result_bytes` as a UTF-8 string.

Size constraint:

* If the peer declares `lcp_manifest.max_payload_bytes`, and the `lcp_result` payload would exceed it, the Provider SHOULD return `lcp_error(code=payload_too_large)`.
  (This spec does not define chunked result delivery.)

---

## 5.5 type: 42095 (`lcp_cancel`)

* data: [`tlv_stream`:`tlvs`]

Optional TLVs:

* type: 70 (`reason`): [`byte`:`reason`] (UTF-8 string)

Meaning:

* On receiving `lcp_cancel`, the receiver SHOULD stop further work for `job_id`.
* If `reason` is present, the receiver MAY use it for logging or display.

---

## 5.6 type: 42097 (`lcp_error`)

* data: [`tlv_stream`:`tlvs`]

Required TLVs:

* type: 80 (`code`): [`u16`:`code`]

Optional TLVs:

* type: 81 (`message`): [`byte`:`message`] (UTF-8 string)

Recommended error codes:

* 1: `unsupported_version`
* 2: `unsupported_task`
* 3: `quote_expired`
* 4: `payment_required`
* 5: `payment_invalid`
* 6: `payload_too_large`
* 7: `rate_limited`
* 8: `unsupported_params`

Note:

* `message` is human-readable supplemental information. Receivers MAY display it.

---

## 6. Minimal state machine

### 6.1 Requester

1. Connect to the Provider (out of scope). Optionally exchange `lcp_manifest`.
2. Send `lcp_quote_request`.
3. Receive `lcp_quote_response`. Verify invoice binding and payee. Pay the invoice.
4. Receive `lcp_result`.

### 6.2 Provider

1. Optionally send `lcp_manifest`. Reply with `lcp_manifest` once if received.
2. Receive `lcp_quote_request`. Return `lcp_quote_response` with an invoice bound to terms.
3. Wait for invoice settlement.
4. Send `lcp_result`.
5. If `lcp_cancel` is received, stop work best-effort.

---

## 7. Security considerations

### 7.1 Replay protection

Receivers MUST de-duplicate by (`job_id`, `msg_id`) at least until `effective_expiry` (see §4.2).

### 7.2 DoS resistance

* Implementations SHOULD enforce payload size limits and per-peer rate limits.
* Providers MAY restrict who they serve (for example pubkey allowlists, or peers with existing channels).
* Providers MAY return `rate_limited`.

### 7.3 Preventing invoice swapping

The Requester MUST satisfy at least:

* `description_hash == terms_hash`
* the invoice payee (destination node pubkey) matches the LCP peer's (Provider's) pubkey

This detects paying an invoice for a different node.

---

## 8. Trade-offs and limitations (direct peer connections)

LCP v0.1 makes the following trade-offs explicit:

* Very small data only. This spec does not define large payload delivery.
* Direct connections. Privacy is not fully preserved compared to onion messages or blinded paths.
* Payment happens before execution. This is not a perfect atomic swap.
* Provider choice remains with the Requester. Small payments keep switching costs low.
* Result delivery is a single message. Large results are awkward.

This specification does not define forwarding via onion messages or blinded paths.
