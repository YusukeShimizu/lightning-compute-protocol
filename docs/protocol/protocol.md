# LCP v0.3 Specification Draft

## Streaming Method Call Protocol over Lightning Custom Messages

---

## 1. Overview, goals, and non-goals

### 1.1 Overview

LCP is an application-layer protocol carried over Lightning’s existing transport (BOLT #1 custom messages).
It enables a **manifest → call → quote → pay → stream → complete** flow using existing Lightning node capabilities (plugins / external processes).
LCP does not modify the BOLTs.

This document defines **LCP v0.3**.

Key properties (v0.3):

* **Not backward compatible** with earlier drafts.
* Uses a **method-call model** (`method` string identifies the procedure).
* **Streaming-only payloads**: request and response bodies are always transferred via streams (chunked messages).
* Provider capability advertisement via mandatory **`lcp_manifest`** before any call messages.

### 1.2 Goals

LCP v0.3 defines:

* A minimal P2P message set to negotiate and execute a **method call**
* Binding between payment (BOLT11 invoice) and call terms to prevent invoice swapping
* Streaming transfer of large **request** and **response** payloads using chunked messages
* Connection-scope capability advertisement (supported methods + limits) via `lcp_manifest`
* Application-layer idempotency and replay resistance for call-scope messages and stream chunks

### 1.3 Non-goals

LCP v0.3 does **not** define:

* Forwarding via onion messages / blinded paths
* Atomic swap guarantees beyond invoice binding
* Standard semantics for any particular method (method semantics are referenced by method documentation)
* Multi-party orchestration
* A new non-Lightning transport

---

## 2. Transport

### 2.1 Direct peer requirement

All LCP v0.3 messages are sent as BOLT #1 custom messages.

* The Requester and Provider MUST have an active Lightning peer connection.
* LCP MUST NOT define or require a new non-Lightning transport.

How the Requester discovers the Provider’s network address is out of scope.

### 2.2 Custom message type range

LCP v0.3 uses the following message type numbers (all ≥ 32768).

BOLT #1 compatibility (odd/even parity rules):

* All LCP message types MUST be odd.
  (Unknown odd messages are ignored; unknown even messages are fatal.)

Assignments:

* 42101: `lcp_manifest`
* 42103: `lcp_call`
* 42105: `lcp_quote`
* 42107: `lcp_complete`
* 42109: `lcp_stream_begin`
* 42111: `lcp_stream_chunk`
* 42113: `lcp_stream_end`
* 42115: `lcp_cancel`
* 42117: `lcp_error`

Receivers MUST ignore unknown TLVs.
Receivers MUST apply BOLT #1 odd/even parity rules to unknown custom message types.

---

## 3. Envelope and encoding

### 3.1 Terminology and requirements language

The key words MUST, MUST NOT, SHOULD, SHOULD NOT, MAY are to be interpreted as described in RFC 2119.

* Requester: the node initiating a call
* Provider: the node executing a call and delivering the response
* Call: a method invocation identified by `call_id` (32 bytes)
* Stream: a payload transferred via `lcp_stream_*` messages
* Connection scope: information tied to a connection (not tied to a call)
* Call scope: information tied to a specific call

### 3.2 Protocol versioning

LCP versions are written as `vMAJOR.MINOR` (for example, v0.3).

The wire field `protocol_version` is a `u16` derived from the (major, minor) pair:

* `protocol_version = major*100 + minor`

This specification defines LCP v0.3, therefore:

* `protocol_version = 3`

Patch-level revisions (v0.3.x) do not change `protocol_version`.

### 3.3 TLV stream encoding

Each LCP message payload is a TLV stream called `tlvs`.

Normative rules (MUST):

* Each TLV record is encoded as `bigsize(type)`, `bigsize(length)`, then `value` (same as BOLT TLV streams).
* Records MUST be sorted in ascending `type`.
* Duplicate records with the same `type` MUST NOT be included.
* Unknown TLVs MUST be ignored.

### 3.4 Common TLVs

#### type: 1 (`protocol_version`)

* data: [`u16`:`protocol_version`]

Rules:

* `protocol_version` MUST be included in every LCP message.
* Implementations that do not support the version SHOULD ignore the message and MAY disconnect.

### 3.5 Call-scope envelope TLVs

The following TLVs are common to all call-scope messages (everything except `lcp_manifest`) (MUST):

* type: 2 (`call_id`): [`32*byte`:`call_id`]
* type: 3 (`msg_id`): [`32*byte`:`msg_id`]
* type: 4 (`expiry`): [`tu64`:`expiry`]

Meaning:

* `call_id` MUST be unpredictable (generated by the Requester).
* `msg_id` MUST be unique within the replay window, per sender, per `call_id`,
  except for `lcp_stream_chunk` where `msg_id` is deterministic (§6.4).
* `expiry` is Unix epoch seconds. The receiver MUST ignore messages where `expiry < now`.

Replay / idempotency retention:

Define:

* `MAX_ENVELOPE_EXPIRY_WINDOW_SECONDS`: implementation-defined (RECOMMENDED: 600).
* `effective_expiry = min(expiry, now + MAX_ENVELOPE_EXPIRY_WINDOW_SECONDS)`

Rules (MUST):

* The receiver MUST de-duplicate by (`call_id`, `msg_id`) at least until `effective_expiry`.
* If a duplicate (`call_id`, `msg_id`) is received before `effective_expiry`, it MUST be ignored.
* If `expiry > now + MAX_ENVELOPE_EXPIRY_WINDOW_SECONDS`, the receiver MUST either:

  * reject/ignore the message, or
  * process it but retain state only until `effective_expiry` (clamp).

### 3.6 Encoding of byte/string TLVs

* Any TLV explicitly specified as a UTF-8 string in this spec MUST be valid UTF-8.
* All other `byte` TLVs MUST be treated as opaque bytes.

### 3.7 List encodings inside TLV values

To represent multiple elements without repeating TLV types in the outer stream, this spec defines list encodings inside TLV values.

#### 3.7.1 `string_list`

* data: `bigsize(count)` + `count` repetitions of (`bigsize(len_i)` + `len_i` bytes)
* Each element MUST be a UTF-8 string.

#### 3.7.2 `bytes_list`

* data: `bigsize(count)` + `count` repetitions of (`bigsize(len_i)` + `len_i` bytes)
* Each element MUST be treated as opaque bytes.

---

## 4. Manifest

### 4.1 `lcp_manifest`

Type: 42101 (`lcp_manifest`)

`lcp_manifest` is a **mandatory** connection-scope message in which each peer declares limits and (optionally) supported methods.

Constraints:

* `lcp_manifest` is connection-scope and MUST NOT include call-scope envelope TLVs (`call_id`, `msg_id`, `expiry`).
* Each side MUST send exactly one `lcp_manifest` per connection.
* No call-scope messages MUST be sent until **both** manifests have been received.

If a call-scope message is received before manifest exchange completes, the receiver MUST ignore it and MAY respond with `lcp_error(code=manifest_required)` (if `call_id` is present).

### 4.2 Manifest TLVs

#### type: 11 (`max_payload_bytes`)

* data: [`tu32`:`max_payload_bytes`]

Meaning:

* Maximum custom-message payload size the sender can receive.
* The peer MUST NOT send messages whose payload exceeds the receiver’s `max_payload_bytes`.
* Implementations SHOULD cap `max_payload_bytes` to roughly 1/4 of the BOLT #1 custom message maximum (65535), e.g. 16384 bytes.

#### type: 14 (`max_stream_bytes`)

* data: [`tu64`:`max_stream_bytes`]

Meaning:

* Maximum total decoded bytes the sender can receive for a single stream.

#### type: 15 (`max_call_bytes`)

* data: [`tu64`:`max_call_bytes`]

Meaning:

* Maximum total decoded bytes the sender can receive across all streams in a call (request + response).

#### type: 16 (`max_inflight_calls`) (optional)

* data: [`u16`:`max_inflight_calls`]

Meaning:

* Maximum concurrent active calls per connection the sender is willing to handle.

#### type: 12 (`supported_methods`) (optional)

* data: [`byte`:`supported_methods`] (`bytes_list`)

Meaning:

* `supported_methods` enumerates method descriptors the Provider accepts in `lcp_call`.
* Each element is a TLV stream called `method_tlvs`.

`method_tlvs` (element TLV stream):

* type: 20 (`method`): UTF-8 string (MUST)
* type: 23 (`request_content_types`) (optional): `string_list`
* type: 24 (`response_content_types`) (optional): `string_list`
* type: 26 (`docs_uri`) (optional): UTF-8 string
* type: 27 (`docs_sha256`) (optional): 32 bytes
* type: 28 (`policy_notice`) (optional): UTF-8 string

Recommended matching rule:

* If `supported_methods` is present and a received `lcp_call.method` does not match, the Provider SHOULD return `lcp_error(code=unsupported_method)`.

---

## 5. Call lifecycle

LCP v0.3 is **streaming-only** for payloads:

* The Requester MUST send the call request payload as a request stream.
* The Provider MUST send the call response payload as a response stream.
* There is no inline request/response body in control messages.

### 5.1 `lcp_call`

Type: 42103 (`lcp_call`)

Starts a call negotiation and declares the method name and an optional small parameter blob.

Required TLVs:

* type: 20 (`method`): [`byte`:`method`] (UTF-8 string)

Optional TLVs:

* type: 22 (`params`): [`byte`:`params`] (opaque bytes)
* type: 25 (`params_content_type`): [`byte`:`params_content_type`] (UTF-8 media type string)

Rules:

* The Provider MAY reject unsupported methods via `lcp_error`.
* If the Provider advertised `supported_methods`, the Requester SHOULD choose a matching method.

Request stream requirement (MUST):

* After sending `lcp_call`, the Requester MUST send exactly one request stream with `stream_kind=request` (§6.1).
* The Provider MUST NOT send `lcp_quote` until it has received and validated the request stream.

Idempotency (recommended):

* If the Provider receives multiple `lcp_call` messages for the same `call_id`, it SHOULD return the same `lcp_quote` if still valid; otherwise it SHOULD return `lcp_error(code=quote_expired)`.

### 5.2 `lcp_quote`

Type: 42105 (`lcp_quote`)

Provides a price and a BOLT11 invoice bound to the call terms.

Required TLVs:

* type: 30 (`price_msat`): [`tu64`:`price_msat`]
* type: 31 (`quote_expiry`): [`tu64`:`quote_expiry`]
* type: 32 (`terms_hash`): [`32*byte`:`terms_hash`]
* type: 33 (`payment_request`): [`byte`:`payment_request`] (BOLT11 invoice string, UTF-8)

Optional TLVs (commitment to response encoding):

* type: 34 (`response_content_type`): UTF-8 string
* type: 35 (`response_content_encoding`): UTF-8 string

Invoice binding (MUST):

* Provider MUST set invoice `description_hash == terms_hash`.
* Before paying, Requester MUST verify:

  * `description_hash == terms_hash`
  * invoice payee pubkey == Provider’s peer pubkey
  * invoice amount == `price_msat` (amount-less invoices MUST be rejected)
  * invoice expiry time does not exceed `quote_expiry`

Invoice time rules (MUST):

* Let `invoice_timestamp_unix` be the invoice timestamp (Unix epoch seconds).
* Let `invoice_expiry_seconds` be invoice expiry (seconds).
* Define `invoice_expiry_unix = invoice_timestamp_unix + invoice_expiry_seconds`.
* Requester MUST verify `invoice_expiry_unix <= quote_expiry`.

  * Clock skew allowance MAY be applied (RECOMMENDED: 5 seconds).

Execution rule (MUST):

* Provider MUST NOT start executing or delivering response payloads until invoice settlement.

#### 5.2.1 `terms_hash` computation

`terms_hash` (MUST):

* `terms_hash = SHA256(tlv_encode(terms_tlvs))`

`terms_tlvs` is a canonical TLV stream containing only:

* type: 1 (`protocol_version`): `u16`
* type: 2 (`call_id`): `32*byte`
* type: 20 (`method`): UTF-8 string
* type: 30 (`price_msat`): `tu64`
* type: 31 (`quote_expiry`): `tu64`
* type: 50 (`request_hash`): `32*byte` (`SHA256(request_decoded_bytes)`)
* type: 52 (`request_len`): `tu64`
* type: 53 (`request_content_type`): UTF-8 string
* type: 54 (`request_content_encoding`): UTF-8 string
* type: 51 (`params_hash`): `32*byte` (`SHA256(params_bytes)` or `SHA256(empty)`)
* type: 55 (`response_content_type`) (optional): UTF-8 string
* type: 56 (`response_content_encoding`) (optional): UTF-8 string

Rules:

* If `params` is present, `params_hash = SHA256(params_bytes)`. Otherwise `SHA256(empty)`.
* If `lcp_quote` includes 34/35, Provider MUST include 55/56 with identical values.

Request binding source (MUST):

* Provider MUST compute request hash/len/content metadata from the **validated request stream** (§6).
* If the request stream cannot be validated, Provider MUST NOT issue a quote.

### 5.3 `lcp_complete`

Type: 42107 (`lcp_complete`)

Terminal call completion message.

Required TLVs:

* type: 100 (`status`): `u16`

  * 0: `ok`
  * 1: `failed`
  * 2: `cancelled`

If a response stream was delivered, include:

* type: 101 (`response_stream_id`): 32 bytes
* type: 102 (`response_hash`): 32 bytes (SHA256 of decoded response bytes)
* type: 103 (`response_len`): `tu64`
* type: 104 (`response_content_type`): UTF-8 string
* type: 105 (`response_content_encoding`): UTF-8 string

If `status != ok`, optional:

* type: 81 (`message`): UTF-8 string

Rules:

* After post-payment execution begins, Provider SHOULD deliver a response stream even for failures (e.g., an error event stream) and then send `lcp_complete(status=failed)` including response stream metadata.
* After receiving `lcp_complete`, Requester SHOULD treat the call as terminal.

### 5.4 Minimal state machine (informative)

Requester:

1. Exchange `lcp_manifest`.
2. Send `lcp_call`.
3. Send request stream.
4. Receive `lcp_quote`, verify, pay.
5. Receive response stream.
6. Receive `lcp_complete`.

Provider:

1. Exchange `lcp_manifest`.
2. Receive `lcp_call`.
3. Receive/validate request stream.
4. Send `lcp_quote`.
5. Wait for invoice settlement.
6. Execute method.
7. Send response stream.
8. Send `lcp_complete`.
9. On `lcp_cancel`, stop best-effort.

---

## 6. Stream transfer

Streams are transferred with:

* `lcp_stream_begin` (42109)
* `lcp_stream_chunk` (42111)
* `lcp_stream_end` (42113)

### 6.1 Stream kinds

* 1: `request`
* 2: `response`

Constraints:

* Exactly one request stream MUST be sent after `lcp_call` and before `lcp_quote`.
* Exactly one response stream SHOULD be sent after payment and before `lcp_complete`.

### 6.2 Content type / encoding

`content_type`:

* UTF-8 media type string (e.g., `application/json; charset=utf-8`).

`content_encoding`:

* UTF-8 identifier describing decoding of chunk bytes into decoded stream bytes.

This spec defines:

* `identity` (MUST be supported)

Receivers MUST reject unknown `content_encoding` with `lcp_error(code=unsupported_encoding)`.

All `sha256` and `total_len` fields refer to **decoded** stream bytes.

### 6.3 `lcp_stream_begin`

Type: 42109

Required TLVs:

* type: 90 (`stream_id`): 32 bytes
* type: 91 (`stream_kind`): `u16`
* type: 94 (`content_type`): UTF-8 string
* type: 95 (`content_encoding`): UTF-8 string

Optional (if known at stream start):

* type: 92 (`total_len`): `tu64`
* type: 93 (`sha256`): 32 bytes

Rules:

* Sender MAY omit `total_len` and `sha256` at begin if unknown.
* Sender MUST provide `total_len` and `sha256` in `lcp_stream_end`.

Limit enforcement (MUST):

* If `total_len` is present, receiver MUST enforce `total_len <= max_stream_bytes`.
* Receiver MUST enforce received decoded bytes do not exceed `max_stream_bytes` even if omitted.
* Receiver MUST enforce total decoded bytes across streams do not exceed `max_call_bytes`.

### 6.4 `lcp_stream_chunk`

Type: 42111

Required TLVs:

* type: 90 (`stream_id`): 32 bytes
* type: 96 (`seq`): `tu32` (0,1,2,…)
* type: 97 (`data`): bytes

Ordering (MUST):

* `seq` MUST start at 0 and increase by exactly 1 for each accepted chunk.
* If `seq < expected_seq`, receiver MUST treat as duplicate and ignore.
* If `seq > expected_seq`, receiver MUST reject with `lcp_error(code=chunk_out_of_order)`.

Deterministic `msg_id` (MUST):

* `msg_id = SHA256(stream_id || u32be(seq))`

Size rule (MUST):

* Sender MUST ensure each message payload size ≤ peer’s `max_payload_bytes`.

### 6.5 `lcp_stream_end`

Type: 42113

Required TLVs:

* type: 90 (`stream_id`): 32 bytes
* type: 92 (`total_len`): `tu64`
* type: 93 (`sha256`): 32 bytes

Validation (MUST):

* Receiver MUST verify:

  * decoded length == `total_len`
  * `SHA256(decoded_bytes) == sha256`
* On failure, receiver MUST send `lcp_error(code=checksum_mismatch)` and SHOULD treat the call as failed.

---

## 7. Event stream format

This section defines an **optional standardized streaming response encoding** for methods that want structured incremental output.

If a method chooses this encoding, it MUST set the response stream:

* `content_type = "application/lcp.events+jsonl; charset=utf-8"`
* `content_encoding = "identity"`

If another content type is used, response bytes are method-defined.

### 7.1 Encoding

For `application/lcp.events+jsonl; charset=utf-8`:

* Decoded bytes MUST be valid UTF-8.
* Response is **JSON Lines**:

  * One JSON object per line
  * Lines separated by `\n` (0x0A)
  * Trailing newline is RECOMMENDED

### 7.2 Minimum frame schema

Each frame MUST be a JSON object with:

* `type`: string
* `seq`: non-negative integer

Optional fields:

* `time`: integer (Unix epoch seconds)
* `data`: any JSON value
* `error`: object

### 7.3 Terminal frame rule

* `seq` MUST start at 0 and increment by 1 per frame.
* Stream MUST include exactly one terminal frame:

  * `type="final"` (success) OR `type="error"` (application failure)
* After terminal frame, sender MUST NOT emit additional frames.

---

## 8. Error, cancel, and rate limiting

### 8.1 `lcp_cancel`

Type: 42115

Optional TLVs:

* type: 70 (`reason`): UTF-8 string

Meaning:

* Receiver SHOULD stop work best-effort.
* Refunds are out of scope.

### 8.2 `lcp_error`

Type: 42117

Protocol-level terminal error (invalid sequencing, unsupported method, stream checksum failure, etc).

Required TLVs:

* type: 80 (`code`): `u16`

Optional TLVs:

* type: 81 (`message`): UTF-8 string

Recommended codes:

* 1: `unsupported_version`
* 2: `manifest_required`
* 3: `unsupported_method`
* 4: `quote_expired`
* 5: `payment_required`
* 6: `payment_invalid`
* 7: `payload_too_large`
* 8: `rate_limited`
* 9: `unsupported_encoding`
* 10: `invalid_state`
* 11: `chunk_out_of_order`
* 12: `checksum_mismatch`
* 13: `stream_limit_exceeded`

Rule of thumb:

* **Protocol** failures → `lcp_error`
* **Method execution** failures → response stream (e.g., terminal event `type="error"`) + `lcp_complete(status=failed)`

---

## 9. Security and policy considerations

### 9.1 Replay protection

Receivers MUST de-duplicate by (`call_id`, `msg_id`) at least until `effective_expiry` (§3.5).
For `lcp_stream_chunk`, `msg_id` is deterministic (§6.4).

### 9.2 DoS resistance

Implementations MUST enforce:

* `max_payload_bytes`
* `max_stream_bytes`
* `max_call_bytes`

Implementations SHOULD rate limit per peer.
Providers MAY restrict service (allowlists, channel requirements, etc).

### 9.3 Invoice swapping prevention

Requester MUST verify at least:

* invoice `description_hash == terms_hash`
* invoice payee pubkey matches Provider peer pubkey

### 9.4 License and usage policy compliance

Providers may invoke upstream models/APIs/datasets.

Rules (MUST):

* Provider MUST comply with applicable licenses, terms of service, and usage policies of any upstream systems used to fulfill a method.
* Provider MUST reject or restrict calls that would violate those obligations.
* Provider SHOULD disclose relevant restrictions via `policy_notice` in method descriptors when feasible.

---
