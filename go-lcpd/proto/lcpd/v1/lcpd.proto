// Copyright 2025 LCP Authors
//
// Licensed under the MIT License.
// See the LICENSE file in the project root for license information.

syntax = "proto3";

// LCPD provides a gRPC API for interacting with LCP peers over Lightning.
//
// LCP (Lightning Compute Protocol) is a Lightning L3 overlay protocol that
// uses BOLT #1 custom messages carrying TLV streams to negotiate and execute
// compute jobs (quote → payment → execution → result delivery).
//
// This API is designed to be compatible with the LCP v0.2 wire protocol
// described in `docs/protocol/protocol.md`.

package lcpd.v1;

option go_package = "github.com/bruwbird/lcp/go-lcpd/gen/go/lcpd/v1;lcpdv1";

import "buf/validate/validate.proto";
import "google/api/field_behavior.proto";
import "google/protobuf/timestamp.proto";

// -----------------------------------------------------------------------------
// Service Definition
// -----------------------------------------------------------------------------

// LCPDService exposes peer discovery and the core LCP quote→pay→execute flow.
//
// Error model:
// RPC failures are returned as canonical gRPC status codes (e.g. INVALID_ARGUMENT,
// NOT_FOUND, FAILED_PRECONDITION, UNAVAILABLE). Message-level validation failures
// are expected to return INVALID_ARGUMENT.
service LCPDService {
  // --- Peer Management ---

  // ListLCPPeers lists currently connected peers that support LCP.
  //
  // Errors:
  // - UNAVAILABLE: The daemon cannot reach the underlying Lightning node (e.g. lnd),
  //   or peer tracking is temporarily unavailable.
  //   Impact: No peer list is returned.
  // - INTERNAL: Unexpected server error.
  //   Impact: No peer list is returned.
  rpc ListLCPPeers(ListLCPPeersRequest) returns (ListLCPPeersResponse);

  // GetLocalInfo gets the local node's LCP information and manifest.
  //
  // Errors:
  // - UNAVAILABLE: The daemon cannot reach the underlying Lightning node (e.g. lnd),
  //   so local identity/capabilities cannot be fetched.
  //   Impact: No local info is returned.
  // - INTERNAL: Unexpected server error.
  //   Impact: No local info is returned.
  rpc GetLocalInfo(GetLocalInfoRequest) returns (GetLocalInfoResponse);

  // --- Core Flow ---

  // RequestQuote sends an `lcp_quote_request` to a specific peer.
  //
  // On success, it returns the provider's `lcp_quote_response` as `Terms`,
  // including a BOLT11 invoice whose `description_hash` MUST equal `terms_hash`
  // (invoice swapping defense).
  // Errors:
  // - INVALID_ARGUMENT: Request validation failed (e.g. `peer_id` format, missing
  //   `task`, or invalid task spec).
  //   Impact: No wire message is sent to the peer.
  // - NOT_FOUND: The target peer is unknown to the daemon.
  //   Impact: No wire message is sent to the peer.
  // - FAILED_PRECONDITION: The target peer is not connected and ready for LCP
  //   (e.g. no manifest observed, protocol mismatch, or LCP disabled).
  //   Impact: No quote is returned; clients may retry after resolving the condition.
  // - RESOURCE_EXHAUSTED: The request would exceed a payload/size limit (local
  //   or remote `max_payload_bytes`), or the daemon refuses due to local policy.
  //   Impact: No quote is returned.
  // - DEADLINE_EXCEEDED: The peer did not respond before the client/server deadline.
  //   Impact: Quote outcome is unknown to the caller; retry MAY result in a new
  //   `job_id` and a different invoice unless the implementation provides idempotency.
  // - UNAVAILABLE: Transient transport failure sending/receiving peer messages.
  //   Impact: Quote outcome is unknown; safe retries depend on idempotency.
  rpc RequestQuote(RequestQuoteRequest) returns (RequestQuoteResponse);

  // AcceptAndExecute pays the invoice associated with the quote and waits for
  // the `lcp_result`.
  //
  // This is a blocking call. Clients SHOULD set a deadline and MAY cancel via
  // context cancellation (gRPC) or `CancelJob`.
  //
  // Errors:
  // - INVALID_ARGUMENT: Request validation failed (e.g. `peer_id`/`job_id` format),
  //   or `pay_invoice=false`.
  //   Impact: No payment attempt is made and no execution is started.
  // - NOT_FOUND: The daemon has no known quote/payment data for the given `job_id`.
  //   Impact: No payment attempt is made.
  // - FAILED_PRECONDITION: The quote is expired, the job is not executable, or the
  //   daemon refuses to pay/execute due to local policy.
  //   Impact: No execution is started.
  // - UNAVAILABLE: Transient failure interacting with the Lightning node for payment,
  //   or transient peer messaging failure for waiting on the result.
  //   Impact: The job/payment outcome may be unknown; callers SHOULD treat retries
  //   with caution because a payment could have succeeded while the result wait failed.
  // - DEADLINE_EXCEEDED: The result did not arrive before the deadline.
  //   Impact: The job may still complete and deliver a result later; callers SHOULD
  //   avoid blindly retrying payment logic.
  // - INTERNAL: Unexpected server error.
  //   Impact: Outcome may be unknown if failure happened after payment settlement.
  rpc AcceptAndExecute(AcceptAndExecuteRequest) returns (AcceptAndExecuteResponse);

  // AcceptAndExecuteStream pays the invoice associated with the quote and streams
  // the decoded result stream bytes as they arrive.
  //
  // The stream ends with a terminal `Result` event that indicates the final job
  // status and (when available) the validated stream metadata (hash/len).
  //
  // Errors follow the same model as `AcceptAndExecute`, but note that streaming
  // responses may have already delivered partial bytes before an error is
  // detected (for example, checksum validation failure at stream end).
  rpc AcceptAndExecuteStream(AcceptAndExecuteStreamRequest)
      returns (stream AcceptAndExecuteStreamResponse);

  // CancelJob sends an `lcp_cancel` message to the provider.
  //
  // Cancellation is best-effort: the provider may have already completed the job.
  //
  // Errors:
  // - INVALID_ARGUMENT: Request validation failed (e.g. `peer_id`/`job_id` format).
  //   Impact: No cancel message is sent.
  // - NOT_FOUND: The target peer is unknown to the daemon.
  //   Impact: No cancel message is sent.
  // - FAILED_PRECONDITION: The daemon cannot currently send peer messages to the
  //   target peer (e.g. not connected).
  //   Impact: No cancel message is sent.
  // - UNAVAILABLE: Transient transport failure sending the cancel message.
  //   Impact: Unknown whether the provider received the cancel; retries are generally safe.
  // - DEADLINE_EXCEEDED: The cancel attempt did not complete before the deadline.
  //   Impact: Unknown whether the provider received the cancel; retries are generally safe.
  // - INTERNAL: Unexpected server error.
  //   Impact: Unknown whether the provider received the cancel.
  rpc CancelJob(CancelJobRequest) returns (CancelJobResponse);
}

// -----------------------------------------------------------------------------
// 1. Task Definitions (Strict & Typed)
// -----------------------------------------------------------------------------

// LCPTaskKind enumerates the supported task types.
// This is primarily used for Manifests and debugging.
enum LCPTaskKind {
  LCP_TASK_KIND_UNSPECIFIED = 0;
  reserved 1;
  reserved "LCP_TASK_KIND_LLM_CHAT";
  LCP_TASK_KIND_OPENAI_CHAT_COMPLETIONS_V1 = 2; // "openai.chat_completions.v1"
  LCP_TASK_KIND_OPENAI_RESPONSES_V1 = 3; // "openai.responses.v1"
}

// Task is the strict container for a job request.
// It uses `oneof` to enforce that only one valid task specification is provided.
message Task {
  reserved 1;
  reserved "llm_chat";

  oneof spec {
    option (buf.validate.oneof).required = true;

    // Structured specification for "openai.chat_completions.v1"
    OpenAIChatCompletionsV1TaskSpec openai_chat_completions_v1 = 2;

    // Structured specification for "openai.responses.v1"
    OpenAIResponsesV1TaskSpec openai_responses_v1 = 3;
  }
}

// OpenAIChatCompletionsV1TaskSpec defines a passthrough OpenAI-compatible
// Chat Completions request. It maps to:
//   - input: raw HTTP request body bytes (JSON)
//   - params: TLV encoded parameters
message OpenAIChatCompletionsV1TaskSpec {
  // Raw HTTP request body bytes for `POST /v1/chat/completions`.
  bytes request_json = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).bytes.min_len = 1
  ];

  // The configuration parameters for routing/validation.
  OpenAIChatCompletionsV1Params params = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).required = true
  ];
}

// OpenAIChatCompletionsV1Params defines the tunable parameters for
// "openai.chat_completions.v1".
message OpenAIChatCompletionsV1Params {
  // "model" (TLV type 1).
  // Identifier for the execution target (for example, an OpenAI model ID).
  string model = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string.min_len = 1
  ];
}

// OpenAIResponsesV1TaskSpec defines a passthrough OpenAI-compatible
// Responses request. It maps to:
//   - input: raw HTTP request body bytes (JSON)
//   - params: TLV encoded parameters
message OpenAIResponsesV1TaskSpec {
  // Raw HTTP request body bytes for `POST /v1/responses`.
  bytes request_json = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).bytes.min_len = 1
  ];

  // The configuration parameters for routing/validation.
  OpenAIResponsesV1Params params = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).required = true
  ];
}

// OpenAIResponsesV1Params defines the tunable parameters for
// "openai.responses.v1".
message OpenAIResponsesV1Params {
  // "model" (TLV type 1).
  // Identifier for the execution target (for example, an OpenAI model ID).
  string model = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string.min_len = 1
  ];
}

// -----------------------------------------------------------------------------
// 2. Protocol Objects (Terms, Result, Manifest)
// -----------------------------------------------------------------------------

// Terms represents the commitment returned by the Provider in `lcp_quote_response`.
message Terms {
  // LCP protocol version (v0.2 = 2; encoding: major*100 + minor).
  uint32 protocol_version = 1 [(buf.validate.field).uint32.const = 2];

  // Job ID (32 bytes).
  bytes job_id = 2 [(buf.validate.field).bytes.len = 32];

  // Price in millisatoshis.
  uint64 price_msat = 3;

  // Quote expiry time.
  //
  // Wire mapping:
  // LCP v0.1 encodes quote expiry as Unix epoch seconds. Implementations that
  // compute or verify `terms_hash` MUST use `quote_expiry.seconds` only and
  // MUST treat `quote_expiry.nanos` as 0.
  google.protobuf.Timestamp quote_expiry = 4 [
    (buf.validate.field).required = true,
    (buf.validate.field).cel_expression = "this.nanos == 0"
  ];

  // The SHA256 commitment over the canonical TLV stream of Terms.
  // Must match the BOLT11 invoice's description_hash.
  bytes terms_hash = 5 [(buf.validate.field).bytes.len = 32];

  // The BOLT11 invoice string provided by the peer.
  string payment_request = 6 [(buf.validate.field).string.min_len = 1];
}

// Result represents the output from `lcp_result`.
message Result {
  // Status represents the job completion state.
  enum Status {
    STATUS_UNSPECIFIED = 0;
    STATUS_OK = 1;
    STATUS_FAILED = 2;
    STATUS_CANCELLED = 3;
  }

  // Completion status for the job.
  Status status = 1 [(buf.validate.field).required = true];

  // If status=OK, the decoded result bytes reconstructed from the result stream.
  // For "openai.chat_completions.v1", the client should interpret this as raw JSON bytes.
  bytes result = 2;

  // If status=OK, these fields reflect the validated result stream metadata.
  bytes result_hash = 3 [(buf.validate.field).bytes.max_len = 32];
  uint64 result_len = 4;
  string content_type = 5;
  string content_encoding = 6;

  // If status!=OK, optional human-readable message.
  string message = 7;
}

// LCPPeer represents a connected peer node.
message LCPPeer {
  // Peer node identifier (Lightning pubkey, hex-encoded 33-byte compressed key).
  string peer_id = 1 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{66}$"
  ];

  // Peer network address, formatted as "host:port".
  string address = 2 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).string.min_len = 1
  ];

  // Remote peer's last observed LCP manifest.
  LCPManifest remote_manifest = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// LCPManifest represents the capabilities declared by a peer via `lcp_manifest`.
message LCPManifest {
  // LCP protocol version (v0.2 = 2; encoding: major*100 + minor).
  uint32 protocol_version = 1 [(buf.validate.field).uint32.const = 2];

  // Maximum supported BOLT #1 custom message payload size in bytes.
  uint32 max_payload_bytes = 11 [
    (buf.validate.field).uint32.gt = 0,
    (buf.validate.field).uint32.lte = 65535
  ];

  // Maximum total decoded bytes supported for a single stream.
  uint64 max_stream_bytes = 14 [(buf.validate.field).uint64.gt = 0];

  // Maximum total decoded bytes supported across all streams in a job.
  uint64 max_job_bytes = 15 [(buf.validate.field).uint64.gt = 0];

  // Optional maximum concurrent in-flight jobs supported per connection.
  // 0 means "unspecified".
  uint32 max_inflight_jobs = 16 [(buf.validate.field).uint32.lte = 65535];

  // Task templates supported by this peer.
  repeated LCPTaskTemplate supported_tasks = 12;
}

// LCPTaskTemplate describes a task kind supported by a peer.
message LCPTaskTemplate {
  // The kind of task supported.
  LCPTaskKind kind = 1 [(buf.validate.field).required = true];

  // The parameter template/defaults supported for this kind.
  oneof params_template {
    option (buf.validate.oneof).required = true;

    OpenAIChatCompletionsV1Params openai_chat_completions_v1 = 3;
    OpenAIResponsesV1Params openai_responses_v1 = 4;
  }

  reserved 2;
  reserved "llm_chat";
}

// -----------------------------------------------------------------------------
// 3. RPC Request/Response Messages
// -----------------------------------------------------------------------------

// ListLCPPeersRequest is the request message for `LCPDService.ListLCPPeers`.
message ListLCPPeersRequest {}

// ListLCPPeersResponse is the response message for `LCPDService.ListLCPPeers`.
message ListLCPPeersResponse {
  repeated LCPPeer peers = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// GetLocalInfoRequest is the request message for `LCPDService.GetLocalInfo`.
message GetLocalInfoRequest {}

// GetLocalInfoResponse is the response message for `LCPDService.GetLocalInfo`.
message GetLocalInfoResponse {
  // Local node identifier (Lightning pubkey, hex-encoded 33-byte compressed key).
  string node_id = 1 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{66}$"
  ];

  // Local node's LCP manifest.
  LCPManifest manifest = 2 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).required = true
  ];
}

// RequestQuoteRequest is the request message for `LCPDService.RequestQuote`.
message RequestQuoteRequest {
  // The target peer's Node ID (Pubkey).
  string peer_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{66}$"
  ];

  // The strict task definition.
  Task task = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).required = true
  ];
}

// RequestQuoteResponse is the response message for `LCPDService.RequestQuote`.
message RequestQuoteResponse {
  // The peer sending the quote.
  string peer_id = 1 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{66}$"
  ];

  // The agreed terms and invoice.
  Terms terms = 2 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).required = true
  ];
}

// AcceptAndExecuteRequest is the request message for `LCPDService.AcceptAndExecute`.
message AcceptAndExecuteRequest {
  // The target peer's Node ID.
  string peer_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{66}$"
  ];

  // The job_id to execute (must match a previously received Quote).
  bytes job_id = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).bytes.len = 32
  ];

  // Authorization to pay the invoice.
  bool pay_invoice = 3 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).required = true
  ];
}

// AcceptAndExecuteStreamRequest is the request message for `LCPDService.AcceptAndExecuteStream`.
message AcceptAndExecuteStreamRequest {
  // The target peer's Node ID.
  string peer_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{66}$"
  ];

  // The job_id to execute (must match a previously received Quote).
  bytes job_id = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).bytes.len = 32
  ];

  // Authorization to pay the invoice.
  bool pay_invoice = 3 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).required = true
  ];
}

// AcceptAndExecuteResponse is the response message for `LCPDService.AcceptAndExecute`.
message AcceptAndExecuteResponse {
  // The execution result.
  Result result = 1 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).required = true
  ];
}

// AcceptAndExecuteStreamResponse is the server-streaming response message for
// `LCPDService.AcceptAndExecuteStream`.
message AcceptAndExecuteStreamResponse {
  oneof event {
    option (buf.validate.oneof).required = true;

    ResultStreamBegin result_begin = 1;
    ResultStreamChunk result_chunk = 2;
    ResultStreamEnd result_end = 3;
    Result result = 4;
  }
}

// ResultStreamBegin marks the start of the decoded result stream.
message ResultStreamBegin {
  // Content type of the decoded result stream bytes.
  string content_type = 1 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).string.min_len = 1
  ];

  // Content encoding of the decoded result stream bytes.
  string content_encoding = 2 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).string.min_len = 1
  ];
}

// ResultStreamChunk carries a contiguous slice of decoded result stream bytes.
message ResultStreamChunk {
  bytes data = 1 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).bytes.min_len = 1
  ];
}

// ResultStreamEnd marks the end of the decoded result stream and contains the
// validated stream metadata.
message ResultStreamEnd {
  bytes result_hash = 1 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).bytes.len = 32
  ];

  uint64 result_len = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// CancelJobRequest is the request message for `LCPDService.CancelJob`.
message CancelJobRequest {
  // The target peer's Node ID.
  string peer_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{66}$"
  ];

  // The job_id to cancel.
  bytes job_id = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).bytes.len = 32
  ];

  // Optional human-readable cancellation reason.
  string reason = 3 [(buf.validate.field).string.max_len = 256];
}

// CancelJobResponse is the response message for `LCPDService.CancelJob`.
message CancelJobResponse {
  bool success = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
}
