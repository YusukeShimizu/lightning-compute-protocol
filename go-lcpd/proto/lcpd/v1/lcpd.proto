// Copyright 2025 LCP Authors
//
// Licensed under the MIT License.
// See the LICENSE file in the project root for license information.

syntax = "proto3";

// LCPD provides a gRPC API for interacting with LCP peers over Lightning.
//
// LCP (Lightning Compute Protocol) is a Lightning L3 overlay protocol that
// uses BOLT #1 custom messages carrying TLV streams to negotiate and execute
// method calls (manifest → call → quote → pay → stream → complete).
//
// This API is designed to be compatible with the LCP v0.3 wire protocol
// described in `docs/protocol/protocol.md`.

package lcpd.v1;

option go_package = "github.com/bruwbird/lcp/go-lcpd/gen/go/lcpd/v1;lcpdv1";

import "buf/validate/validate.proto";
import "google/api/field_behavior.proto";
import "google/protobuf/timestamp.proto";

// -----------------------------------------------------------------------------
// Service Definition
// -----------------------------------------------------------------------------

// LCPDService exposes peer discovery and the core LCP quote→pay→execute flow.
//
// Error model:
// RPC failures are returned as canonical gRPC status codes (e.g. INVALID_ARGUMENT,
// NOT_FOUND, FAILED_PRECONDITION, UNAVAILABLE). Message-level validation failures
// are expected to return INVALID_ARGUMENT.
service LCPDService {
  // --- Peer Management ---

  // ListLCPPeers lists currently connected peers that support LCP.
  //
  // Errors:
  // - UNAVAILABLE: The daemon cannot reach the underlying Lightning node (e.g. lnd),
  //   or peer tracking is temporarily unavailable.
  //   Impact: No peer list is returned.
  // - INTERNAL: Unexpected server error.
  //   Impact: No peer list is returned.
  rpc ListLCPPeers(ListLCPPeersRequest) returns (ListLCPPeersResponse);

  // GetLocalInfo gets the local node's LCP information and manifest.
  //
  // Errors:
  // - UNAVAILABLE: The daemon cannot reach the underlying Lightning node (e.g. lnd),
  //   so local identity/capabilities cannot be fetched.
  //   Impact: No local info is returned.
  // - INTERNAL: Unexpected server error.
  //   Impact: No local info is returned.
  rpc GetLocalInfo(GetLocalInfoRequest) returns (GetLocalInfoResponse);

  // --- Core Flow ---

  // RequestQuote sends an `lcp_call` and a request stream to a specific peer.
  //
  // On success, it returns the provider's `lcp_quote` as `Quote`,
  // including a BOLT11 invoice whose `description_hash` MUST equal `terms_hash`
  // (invoice swapping defense).
  // Errors:
  // - INVALID_ARGUMENT: Request validation failed (e.g. `peer_id` format, missing
  //   `call`, or invalid call spec).
  //   Impact: No wire message is sent to the peer.
  // - NOT_FOUND: The target peer is unknown to the daemon.
  //   Impact: No wire message is sent to the peer.
  // - FAILED_PRECONDITION: The target peer is not connected and ready for LCP
  //   (e.g. no manifest observed, protocol mismatch, or LCP disabled).
  //   Impact: No quote is returned; clients may retry after resolving the condition.
  // - RESOURCE_EXHAUSTED: The request would exceed a payload/size limit (local
  //   or remote `max_payload_bytes`), or the daemon refuses due to local policy.
  //   Impact: No quote is returned.
  // - DEADLINE_EXCEEDED: The peer did not respond before the client/server deadline.
  //   Impact: Quote outcome is unknown to the caller; retry MAY result in a new
  //   `call_id` and a different invoice unless the implementation provides idempotency.
  // - UNAVAILABLE: Transient transport failure sending/receiving peer messages.
  //   Impact: Quote outcome is unknown; safe retries depend on idempotency.
  rpc RequestQuote(RequestQuoteRequest) returns (RequestQuoteResponse);

  // AcceptAndExecute pays the invoice associated with the quote and waits for
  // the terminal `lcp_complete` and (when available) the validated response stream.
  //
  // This is a blocking call. Clients SHOULD set a deadline and MAY cancel via
  // context cancellation (gRPC) or `CancelJob`.
  //
  // Errors:
  // - INVALID_ARGUMENT: Request validation failed (e.g. `peer_id`/`call_id` format),
  //   or `pay_invoice=false`.
  //   Impact: No payment attempt is made and no execution is started.
  // - NOT_FOUND: The daemon has no known quote/payment data for the given `call_id`.
  //   Impact: No payment attempt is made.
  // - FAILED_PRECONDITION: The quote is expired, the job is not executable, or the
  //   daemon refuses to pay/execute due to local policy.
  //   Impact: No execution is started.
  // - UNAVAILABLE: Transient failure interacting with the Lightning node for payment,
  //   or transient peer messaging failure for waiting on the result.
  //   Impact: The job/payment outcome may be unknown; callers SHOULD treat retries
  //   with caution because a payment could have succeeded while the result wait failed.
  // - DEADLINE_EXCEEDED: The result did not arrive before the deadline.
  //   Impact: The job may still complete and deliver a result later; callers SHOULD
  //   avoid blindly retrying payment logic.
  // - INTERNAL: Unexpected server error.
  //   Impact: Outcome may be unknown if failure happened after payment settlement.
  rpc AcceptAndExecute(AcceptAndExecuteRequest) returns (AcceptAndExecuteResponse);

  // AcceptAndExecuteStream pays the invoice associated with the quote and streams
  // the decoded response stream bytes as they arrive.
  //
  // The stream ends with a terminal `Complete` event that indicates the final job
  // status and (when available) the validated stream metadata (hash/len).
  //
  // Errors follow the same model as `AcceptAndExecute`, but note that streaming
  // responses may have already delivered partial bytes before an error is
  // detected (for example, checksum validation failure at stream end).
  rpc AcceptAndExecuteStream(AcceptAndExecuteStreamRequest)
      returns (stream AcceptAndExecuteStreamResponse);

  // CancelJob sends an `lcp_cancel` message to the provider.
  //
  // Cancellation is best-effort: the provider may have already completed the job.
  //
  // Errors:
  // - INVALID_ARGUMENT: Request validation failed (e.g. `peer_id`/`call_id` format).
  //   Impact: No cancel message is sent.
  // - NOT_FOUND: The target peer is unknown to the daemon.
  //   Impact: No cancel message is sent.
  // - FAILED_PRECONDITION: The daemon cannot currently send peer messages to the
  //   target peer (e.g. not connected).
  //   Impact: No cancel message is sent.
  // - UNAVAILABLE: Transient transport failure sending the cancel message.
  //   Impact: Unknown whether the provider received the cancel; retries are generally safe.
  // - DEADLINE_EXCEEDED: The cancel attempt did not complete before the deadline.
  //   Impact: Unknown whether the provider received the cancel; retries are generally safe.
  // - INTERNAL: Unexpected server error.
  //   Impact: Unknown whether the provider received the cancel.
  rpc CancelJob(CancelJobRequest) returns (CancelJobResponse);
}

// -----------------------------------------------------------------------------
// 1. Call Definitions (Client-Facing)
// -----------------------------------------------------------------------------

// CallSpec describes the Requester's method call and the corresponding request
// payload. The LCP wire protocol transmits the request payload via stream
// messages; this gRPC API accepts the decoded bytes and streams them over LCP.
message CallSpec {
  // Method name (wire mapping: `lcp_call.method`).
  string method = 1 [(buf.validate.field).string.min_len = 1];

  // Opaque method params bytes (wire mapping: `lcp_call.params`).
  // For LCP v0.3, params are method-defined opaque bytes (often a TLV stream).
  bytes params = 2;

  // Optional params content type hint (wire mapping: `lcp_call.params_content_type`).
  string params_content_type = 3;

  // Decoded request bytes to send in the request stream.
  bytes request_bytes = 4 [(buf.validate.field).bytes.min_len = 1];

  // Request stream content type (wire mapping: `lcp_stream_begin.content_type`).
  string request_content_type = 5 [(buf.validate.field).string.min_len = 1];

  // Request stream content encoding (wire mapping: `lcp_stream_begin.content_encoding`).
  string request_content_encoding = 6 [(buf.validate.field).string.min_len = 1];
}

// -----------------------------------------------------------------------------
// 2. Protocol Objects (Quote, Complete, Manifest)
// -----------------------------------------------------------------------------

// Quote represents the commitment returned by the Provider in `lcp_quote`.
message Quote {
  // LCP protocol version (v0.3 = 3; encoding: major*100 + minor).
  uint32 protocol_version = 1 [(buf.validate.field).uint32.const = 3];

  // Call ID (32 bytes).
  bytes call_id = 2 [(buf.validate.field).bytes.len = 32];

  // Price in millisatoshis.
  uint64 price_msat = 3;

  // Quote expiry time.
  //
  // Wire mapping:
  // LCP v0.1 encodes quote expiry as Unix epoch seconds. Implementations that
  // compute or verify `terms_hash` MUST use `quote_expiry.seconds` only and
  // MUST treat `quote_expiry.nanos` as 0.
  google.protobuf.Timestamp quote_expiry = 4 [
    (buf.validate.field).required = true,
    (buf.validate.field).cel_expression = "this.nanos == 0"
  ];

  // The SHA256 commitment over the canonical TLV stream of terms_tlvs.
  // Must match the BOLT11 invoice's description_hash.
  bytes terms_hash = 5 [(buf.validate.field).bytes.len = 32];

  // The BOLT11 invoice string provided by the peer.
  string payment_request = 6 [(buf.validate.field).string.min_len = 1];

  // Optional provider commitment to response stream encoding.
  optional string response_content_type = 7 [(buf.validate.field).string.min_len = 1];
  optional string response_content_encoding = 8 [(buf.validate.field).string.min_len = 1];
}

// Complete represents the terminal completion state from `lcp_complete`.
// For status=OK, it also includes the validated response stream metadata and
// (for unary RPCs) the reconstructed decoded response bytes.
message Complete {
  // Status represents the job completion state.
  enum Status {
    STATUS_UNSPECIFIED = 0;
    STATUS_OK = 1;
    STATUS_FAILED = 2;
    STATUS_CANCELLED = 3;
  }

  // Completion status for the job.
  Status status = 1 [(buf.validate.field).required = true];

  // If status=OK, the decoded response bytes reconstructed from the response stream.
  bytes response_bytes = 2;

  // If status=OK, these fields reflect the validated response stream metadata.
  optional bytes response_stream_id = 3 [(buf.validate.field).bytes.len = 32];
  optional bytes response_hash = 4 [(buf.validate.field).bytes.len = 32];
  optional uint64 response_len = 5;
  optional string response_content_type = 6 [(buf.validate.field).string.min_len = 1];
  optional string response_content_encoding = 7 [(buf.validate.field).string.min_len = 1];

  // If status!=OK, optional human-readable message.
  string message = 8;
}

// MethodDescriptor represents one entry of `supported_methods` in `lcp_manifest`.
message MethodDescriptor {
  // Method name.
  string method = 1 [(buf.validate.field).string.min_len = 1];

  // Optional hints for request/response stream content type selection.
  repeated string request_content_types = 2;
  repeated string response_content_types = 3;

  // Optional documentation metadata.
  optional string docs_uri = 4 [(buf.validate.field).string.min_len = 1];
  optional bytes docs_sha256 = 5 [(buf.validate.field).bytes.len = 32];

  // Optional human-readable policy notice (for example, pricing or limits).
  optional string policy_notice = 6 [(buf.validate.field).string.min_len = 1];
}

// LCPPeer represents a connected peer node.
message LCPPeer {
  // Peer node identifier (Lightning pubkey, hex-encoded 33-byte compressed key).
  string peer_id = 1 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{66}$"
  ];

  // Peer network address, formatted as "host:port".
  string address = 2 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).string.min_len = 1
  ];

  // Remote peer's last observed LCP manifest.
  LCPManifest remote_manifest = 3 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// LCPManifest represents the capabilities declared by a peer via `lcp_manifest`.
message LCPManifest {
  // LCP protocol version (v0.3 = 3; encoding: major*100 + minor).
  uint32 protocol_version = 1 [(buf.validate.field).uint32.const = 3];

  // Maximum supported BOLT #1 custom message payload size in bytes.
  uint32 max_payload_bytes = 11 [
    (buf.validate.field).uint32.gt = 0,
    (buf.validate.field).uint32.lte = 65535
  ];

  // Maximum total decoded bytes supported for a single stream.
  uint64 max_stream_bytes = 14 [(buf.validate.field).uint64.gt = 0];

  // Maximum total decoded bytes supported across all streams in a job.
  uint64 max_call_bytes = 15 [(buf.validate.field).uint64.gt = 0];

  // Optional maximum concurrent in-flight jobs supported per connection.
  // 0 means "unspecified".
  uint32 max_inflight_calls = 16 [(buf.validate.field).uint32.lte = 65535];

  // Methods supported by this peer.
  repeated MethodDescriptor supported_methods = 12;
}

// -----------------------------------------------------------------------------
// 3. RPC Request/Response Messages
// -----------------------------------------------------------------------------

// ListLCPPeersRequest is the request message for `LCPDService.ListLCPPeers`.
message ListLCPPeersRequest {}

// ListLCPPeersResponse is the response message for `LCPDService.ListLCPPeers`.
message ListLCPPeersResponse {
  repeated LCPPeer peers = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// GetLocalInfoRequest is the request message for `LCPDService.GetLocalInfo`.
message GetLocalInfoRequest {}

// GetLocalInfoResponse is the response message for `LCPDService.GetLocalInfo`.
message GetLocalInfoResponse {
  // Local node identifier (Lightning pubkey, hex-encoded 33-byte compressed key).
  string node_id = 1 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{66}$"
  ];

  // Local node's LCP manifest.
  LCPManifest manifest = 2 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).required = true
  ];
}

// RequestQuoteRequest is the request message for `LCPDService.RequestQuote`.
message RequestQuoteRequest {
  // The target peer's Node ID (Pubkey).
  string peer_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{66}$"
  ];

  // The method call specification.
  CallSpec call = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).required = true
  ];
}

// RequestQuoteResponse is the response message for `LCPDService.RequestQuote`.
message RequestQuoteResponse {
  // The peer sending the quote.
  string peer_id = 1 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{66}$"
  ];

  // The agreed quote and invoice.
  Quote quote = 2 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).required = true
  ];
}

// AcceptAndExecuteRequest is the request message for `LCPDService.AcceptAndExecute`.
message AcceptAndExecuteRequest {
  // The target peer's Node ID.
  string peer_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{66}$"
  ];

  // The call_id to execute (must match a previously received Quote).
  bytes call_id = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).bytes.len = 32
  ];

  // Authorization to pay the invoice.
  bool pay_invoice = 3 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).required = true
  ];
}

// AcceptAndExecuteStreamRequest is the request message for `LCPDService.AcceptAndExecuteStream`.
message AcceptAndExecuteStreamRequest {
  // The target peer's Node ID.
  string peer_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{66}$"
  ];

  // The call_id to execute (must match a previously received Quote).
  bytes call_id = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).bytes.len = 32
  ];

  // Authorization to pay the invoice.
  bool pay_invoice = 3 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).required = true
  ];
}

// AcceptAndExecuteResponse is the response message for `LCPDService.AcceptAndExecute`.
message AcceptAndExecuteResponse {
  // The execution result.
  Complete complete = 1 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).required = true
  ];
}

// AcceptAndExecuteStreamResponse is the server-streaming response message for
// `LCPDService.AcceptAndExecuteStream`.
message AcceptAndExecuteStreamResponse {
  oneof event {
    option (buf.validate.oneof).required = true;

    ResponseStreamBegin response_begin = 1;
    ResponseStreamChunk response_chunk = 2;
    ResponseStreamEnd response_end = 3;
    Complete complete = 4;
  }
}

// ResponseStreamBegin marks the start of the decoded response stream.
message ResponseStreamBegin {
  // Content type of the decoded response stream bytes.
  string content_type = 1 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).string.min_len = 1
  ];

  // Content encoding of the decoded response stream bytes.
  string content_encoding = 2 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).string.min_len = 1
  ];
}

// ResponseStreamChunk carries a contiguous slice of decoded response stream bytes.
message ResponseStreamChunk {
  bytes data = 1 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).bytes.min_len = 1
  ];
}

// ResponseStreamEnd marks the end of the decoded response stream and contains the
// validated stream metadata.
message ResponseStreamEnd {
  bytes response_hash = 1 [
    (google.api.field_behavior) = OUTPUT_ONLY,
    (buf.validate.field).bytes.len = 32
  ];

  uint64 response_len = 2 [(google.api.field_behavior) = OUTPUT_ONLY];
}

// CancelJobRequest is the request message for `LCPDService.CancelJob`.
message CancelJobRequest {
  // The target peer's Node ID.
  string peer_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{66}$"
  ];

  // The call_id to cancel.
  bytes call_id = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).bytes.len = 32
  ];

  // Optional human-readable cancellation reason.
  string reason = 3 [(buf.validate.field).string.max_len = 256];
}

// CancelJobResponse is the response message for `LCPDService.CancelJob`.
message CancelJobResponse {
  bool success = 1 [(google.api.field_behavior) = OUTPUT_ONLY];
}
