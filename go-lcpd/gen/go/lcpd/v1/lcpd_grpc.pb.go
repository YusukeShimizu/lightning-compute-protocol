// Copyright 2025 LCP Authors
//
// Licensed under the MIT License.
// See the LICENSE file in the project root for license information.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: lcpd/v1/lcpd.proto

// LCPD provides a gRPC API for interacting with LCP peers over Lightning.
//
// LCP (Lightning Compute Protocol) is a Lightning L3 overlay protocol that
// uses BOLT #1 custom messages carrying TLV streams to negotiate and execute
// compute jobs (quote → payment → execution → result delivery).
//
// This API is designed to be compatible with the LCP v0.1 wire protocol
// described in `docs/protocol/protocol.md`.

package lcpdv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	LCPDService_ListLCPPeers_FullMethodName     = "/lcpd.v1.LCPDService/ListLCPPeers"
	LCPDService_GetLocalInfo_FullMethodName     = "/lcpd.v1.LCPDService/GetLocalInfo"
	LCPDService_RequestQuote_FullMethodName     = "/lcpd.v1.LCPDService/RequestQuote"
	LCPDService_AcceptAndExecute_FullMethodName = "/lcpd.v1.LCPDService/AcceptAndExecute"
	LCPDService_CancelJob_FullMethodName        = "/lcpd.v1.LCPDService/CancelJob"
)

// LCPDServiceClient is the client API for LCPDService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// LCPDService exposes peer discovery and the core LCP quote→pay→execute flow.
//
// Error model:
// RPC failures are returned as canonical gRPC status codes (e.g. INVALID_ARGUMENT,
// NOT_FOUND, FAILED_PRECONDITION, UNAVAILABLE). Message-level validation failures
// are expected to return INVALID_ARGUMENT.
type LCPDServiceClient interface {
	// ListLCPPeers lists currently connected peers that support LCP.
	//
	// Errors:
	//   - UNAVAILABLE: The daemon cannot reach the underlying Lightning node (e.g. lnd),
	//     or peer tracking is temporarily unavailable.
	//     Impact: No peer list is returned.
	//   - INTERNAL: Unexpected server error.
	//     Impact: No peer list is returned.
	ListLCPPeers(ctx context.Context, in *ListLCPPeersRequest, opts ...grpc.CallOption) (*ListLCPPeersResponse, error)
	// GetLocalInfo gets the local node's LCP information and manifest.
	//
	// Errors:
	//   - UNAVAILABLE: The daemon cannot reach the underlying Lightning node (e.g. lnd),
	//     so local identity/capabilities cannot be fetched.
	//     Impact: No local info is returned.
	//   - INTERNAL: Unexpected server error.
	//     Impact: No local info is returned.
	GetLocalInfo(ctx context.Context, in *GetLocalInfoRequest, opts ...grpc.CallOption) (*GetLocalInfoResponse, error)
	// RequestQuote sends an `lcp_quote_request` to a specific peer.
	//
	// On success, it returns the provider's `lcp_quote_response` as `Terms`,
	// including a BOLT11 invoice whose `description_hash` MUST equal `terms_hash`
	// (invoice swapping defense).
	// Errors:
	//   - INVALID_ARGUMENT: Request validation failed (e.g. `peer_id` format, missing
	//     `task`, or invalid task spec).
	//     Impact: No wire message is sent to the peer.
	//   - NOT_FOUND: The target peer is unknown to the daemon.
	//     Impact: No wire message is sent to the peer.
	//   - FAILED_PRECONDITION: The target peer is not connected and ready for LCP
	//     (e.g. no manifest observed, protocol mismatch, or LCP disabled).
	//     Impact: No quote is returned; clients may retry after resolving the condition.
	//   - RESOURCE_EXHAUSTED: The request would exceed a payload/size limit (local
	//     or remote `max_payload_bytes`), or the daemon refuses due to local policy.
	//     Impact: No quote is returned.
	//   - DEADLINE_EXCEEDED: The peer did not respond before the client/server deadline.
	//     Impact: Quote outcome is unknown to the caller; retry MAY result in a new
	//     `job_id` and a different invoice unless the implementation provides idempotency.
	//   - UNAVAILABLE: Transient transport failure sending/receiving peer messages.
	//     Impact: Quote outcome is unknown; safe retries depend on idempotency.
	RequestQuote(ctx context.Context, in *RequestQuoteRequest, opts ...grpc.CallOption) (*RequestQuoteResponse, error)
	// AcceptAndExecute pays the invoice associated with the quote and waits for
	// the `lcp_result`.
	//
	// This is a blocking call. Clients SHOULD set a deadline and MAY cancel via
	// context cancellation (gRPC) or `CancelJob`.
	//
	// Errors:
	//   - INVALID_ARGUMENT: Request validation failed (e.g. `peer_id`/`job_id` format),
	//     or `pay_invoice=false`.
	//     Impact: No payment attempt is made and no execution is started.
	//   - NOT_FOUND: The daemon has no known quote/payment data for the given `job_id`.
	//     Impact: No payment attempt is made.
	//   - FAILED_PRECONDITION: The quote is expired, the job is not executable, or the
	//     daemon refuses to pay/execute due to local policy.
	//     Impact: No execution is started.
	//   - UNAVAILABLE: Transient failure interacting with the Lightning node for payment,
	//     or transient peer messaging failure for waiting on the result.
	//     Impact: The job/payment outcome may be unknown; callers SHOULD treat retries
	//     with caution because a payment could have succeeded while the result wait failed.
	//   - DEADLINE_EXCEEDED: The result did not arrive before the deadline.
	//     Impact: The job may still complete and deliver a result later; callers SHOULD
	//     avoid blindly retrying payment logic.
	//   - INTERNAL: Unexpected server error.
	//     Impact: Outcome may be unknown if failure happened after payment settlement.
	AcceptAndExecute(ctx context.Context, in *AcceptAndExecuteRequest, opts ...grpc.CallOption) (*AcceptAndExecuteResponse, error)
	// CancelJob sends an `lcp_cancel` message to the provider.
	//
	// Cancellation is best-effort: the provider may have already completed the job.
	//
	// Errors:
	//   - INVALID_ARGUMENT: Request validation failed (e.g. `peer_id`/`job_id` format).
	//     Impact: No cancel message is sent.
	//   - NOT_FOUND: The target peer is unknown to the daemon.
	//     Impact: No cancel message is sent.
	//   - FAILED_PRECONDITION: The daemon cannot currently send peer messages to the
	//     target peer (e.g. not connected).
	//     Impact: No cancel message is sent.
	//   - UNAVAILABLE: Transient transport failure sending the cancel message.
	//     Impact: Unknown whether the provider received the cancel; retries are generally safe.
	//   - DEADLINE_EXCEEDED: The cancel attempt did not complete before the deadline.
	//     Impact: Unknown whether the provider received the cancel; retries are generally safe.
	//   - INTERNAL: Unexpected server error.
	//     Impact: Unknown whether the provider received the cancel.
	CancelJob(ctx context.Context, in *CancelJobRequest, opts ...grpc.CallOption) (*CancelJobResponse, error)
}

type lCPDServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLCPDServiceClient(cc grpc.ClientConnInterface) LCPDServiceClient {
	return &lCPDServiceClient{cc}
}

func (c *lCPDServiceClient) ListLCPPeers(ctx context.Context, in *ListLCPPeersRequest, opts ...grpc.CallOption) (*ListLCPPeersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLCPPeersResponse)
	err := c.cc.Invoke(ctx, LCPDService_ListLCPPeers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lCPDServiceClient) GetLocalInfo(ctx context.Context, in *GetLocalInfoRequest, opts ...grpc.CallOption) (*GetLocalInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLocalInfoResponse)
	err := c.cc.Invoke(ctx, LCPDService_GetLocalInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lCPDServiceClient) RequestQuote(ctx context.Context, in *RequestQuoteRequest, opts ...grpc.CallOption) (*RequestQuoteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestQuoteResponse)
	err := c.cc.Invoke(ctx, LCPDService_RequestQuote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lCPDServiceClient) AcceptAndExecute(ctx context.Context, in *AcceptAndExecuteRequest, opts ...grpc.CallOption) (*AcceptAndExecuteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AcceptAndExecuteResponse)
	err := c.cc.Invoke(ctx, LCPDService_AcceptAndExecute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lCPDServiceClient) CancelJob(ctx context.Context, in *CancelJobRequest, opts ...grpc.CallOption) (*CancelJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelJobResponse)
	err := c.cc.Invoke(ctx, LCPDService_CancelJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LCPDServiceServer is the server API for LCPDService service.
// All implementations must embed UnimplementedLCPDServiceServer
// for forward compatibility.
//
// LCPDService exposes peer discovery and the core LCP quote→pay→execute flow.
//
// Error model:
// RPC failures are returned as canonical gRPC status codes (e.g. INVALID_ARGUMENT,
// NOT_FOUND, FAILED_PRECONDITION, UNAVAILABLE). Message-level validation failures
// are expected to return INVALID_ARGUMENT.
type LCPDServiceServer interface {
	// ListLCPPeers lists currently connected peers that support LCP.
	//
	// Errors:
	//   - UNAVAILABLE: The daemon cannot reach the underlying Lightning node (e.g. lnd),
	//     or peer tracking is temporarily unavailable.
	//     Impact: No peer list is returned.
	//   - INTERNAL: Unexpected server error.
	//     Impact: No peer list is returned.
	ListLCPPeers(context.Context, *ListLCPPeersRequest) (*ListLCPPeersResponse, error)
	// GetLocalInfo gets the local node's LCP information and manifest.
	//
	// Errors:
	//   - UNAVAILABLE: The daemon cannot reach the underlying Lightning node (e.g. lnd),
	//     so local identity/capabilities cannot be fetched.
	//     Impact: No local info is returned.
	//   - INTERNAL: Unexpected server error.
	//     Impact: No local info is returned.
	GetLocalInfo(context.Context, *GetLocalInfoRequest) (*GetLocalInfoResponse, error)
	// RequestQuote sends an `lcp_quote_request` to a specific peer.
	//
	// On success, it returns the provider's `lcp_quote_response` as `Terms`,
	// including a BOLT11 invoice whose `description_hash` MUST equal `terms_hash`
	// (invoice swapping defense).
	// Errors:
	//   - INVALID_ARGUMENT: Request validation failed (e.g. `peer_id` format, missing
	//     `task`, or invalid task spec).
	//     Impact: No wire message is sent to the peer.
	//   - NOT_FOUND: The target peer is unknown to the daemon.
	//     Impact: No wire message is sent to the peer.
	//   - FAILED_PRECONDITION: The target peer is not connected and ready for LCP
	//     (e.g. no manifest observed, protocol mismatch, or LCP disabled).
	//     Impact: No quote is returned; clients may retry after resolving the condition.
	//   - RESOURCE_EXHAUSTED: The request would exceed a payload/size limit (local
	//     or remote `max_payload_bytes`), or the daemon refuses due to local policy.
	//     Impact: No quote is returned.
	//   - DEADLINE_EXCEEDED: The peer did not respond before the client/server deadline.
	//     Impact: Quote outcome is unknown to the caller; retry MAY result in a new
	//     `job_id` and a different invoice unless the implementation provides idempotency.
	//   - UNAVAILABLE: Transient transport failure sending/receiving peer messages.
	//     Impact: Quote outcome is unknown; safe retries depend on idempotency.
	RequestQuote(context.Context, *RequestQuoteRequest) (*RequestQuoteResponse, error)
	// AcceptAndExecute pays the invoice associated with the quote and waits for
	// the `lcp_result`.
	//
	// This is a blocking call. Clients SHOULD set a deadline and MAY cancel via
	// context cancellation (gRPC) or `CancelJob`.
	//
	// Errors:
	//   - INVALID_ARGUMENT: Request validation failed (e.g. `peer_id`/`job_id` format),
	//     or `pay_invoice=false`.
	//     Impact: No payment attempt is made and no execution is started.
	//   - NOT_FOUND: The daemon has no known quote/payment data for the given `job_id`.
	//     Impact: No payment attempt is made.
	//   - FAILED_PRECONDITION: The quote is expired, the job is not executable, or the
	//     daemon refuses to pay/execute due to local policy.
	//     Impact: No execution is started.
	//   - UNAVAILABLE: Transient failure interacting with the Lightning node for payment,
	//     or transient peer messaging failure for waiting on the result.
	//     Impact: The job/payment outcome may be unknown; callers SHOULD treat retries
	//     with caution because a payment could have succeeded while the result wait failed.
	//   - DEADLINE_EXCEEDED: The result did not arrive before the deadline.
	//     Impact: The job may still complete and deliver a result later; callers SHOULD
	//     avoid blindly retrying payment logic.
	//   - INTERNAL: Unexpected server error.
	//     Impact: Outcome may be unknown if failure happened after payment settlement.
	AcceptAndExecute(context.Context, *AcceptAndExecuteRequest) (*AcceptAndExecuteResponse, error)
	// CancelJob sends an `lcp_cancel` message to the provider.
	//
	// Cancellation is best-effort: the provider may have already completed the job.
	//
	// Errors:
	//   - INVALID_ARGUMENT: Request validation failed (e.g. `peer_id`/`job_id` format).
	//     Impact: No cancel message is sent.
	//   - NOT_FOUND: The target peer is unknown to the daemon.
	//     Impact: No cancel message is sent.
	//   - FAILED_PRECONDITION: The daemon cannot currently send peer messages to the
	//     target peer (e.g. not connected).
	//     Impact: No cancel message is sent.
	//   - UNAVAILABLE: Transient transport failure sending the cancel message.
	//     Impact: Unknown whether the provider received the cancel; retries are generally safe.
	//   - DEADLINE_EXCEEDED: The cancel attempt did not complete before the deadline.
	//     Impact: Unknown whether the provider received the cancel; retries are generally safe.
	//   - INTERNAL: Unexpected server error.
	//     Impact: Unknown whether the provider received the cancel.
	CancelJob(context.Context, *CancelJobRequest) (*CancelJobResponse, error)
	mustEmbedUnimplementedLCPDServiceServer()
}

// UnimplementedLCPDServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLCPDServiceServer struct{}

func (UnimplementedLCPDServiceServer) ListLCPPeers(context.Context, *ListLCPPeersRequest) (*ListLCPPeersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLCPPeers not implemented")
}
func (UnimplementedLCPDServiceServer) GetLocalInfo(context.Context, *GetLocalInfoRequest) (*GetLocalInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocalInfo not implemented")
}
func (UnimplementedLCPDServiceServer) RequestQuote(context.Context, *RequestQuoteRequest) (*RequestQuoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestQuote not implemented")
}
func (UnimplementedLCPDServiceServer) AcceptAndExecute(context.Context, *AcceptAndExecuteRequest) (*AcceptAndExecuteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcceptAndExecute not implemented")
}
func (UnimplementedLCPDServiceServer) CancelJob(context.Context, *CancelJobRequest) (*CancelJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelJob not implemented")
}
func (UnimplementedLCPDServiceServer) mustEmbedUnimplementedLCPDServiceServer() {}
func (UnimplementedLCPDServiceServer) testEmbeddedByValue()                     {}

// UnsafeLCPDServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LCPDServiceServer will
// result in compilation errors.
type UnsafeLCPDServiceServer interface {
	mustEmbedUnimplementedLCPDServiceServer()
}

func RegisterLCPDServiceServer(s grpc.ServiceRegistrar, srv LCPDServiceServer) {
	// If the following call pancis, it indicates UnimplementedLCPDServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LCPDService_ServiceDesc, srv)
}

func _LCPDService_ListLCPPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLCPPeersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LCPDServiceServer).ListLCPPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LCPDService_ListLCPPeers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LCPDServiceServer).ListLCPPeers(ctx, req.(*ListLCPPeersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LCPDService_GetLocalInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLocalInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LCPDServiceServer).GetLocalInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LCPDService_GetLocalInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LCPDServiceServer).GetLocalInfo(ctx, req.(*GetLocalInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LCPDService_RequestQuote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestQuoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LCPDServiceServer).RequestQuote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LCPDService_RequestQuote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LCPDServiceServer).RequestQuote(ctx, req.(*RequestQuoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LCPDService_AcceptAndExecute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptAndExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LCPDServiceServer).AcceptAndExecute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LCPDService_AcceptAndExecute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LCPDServiceServer).AcceptAndExecute(ctx, req.(*AcceptAndExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LCPDService_CancelJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LCPDServiceServer).CancelJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LCPDService_CancelJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LCPDServiceServer).CancelJob(ctx, req.(*CancelJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LCPDService_ServiceDesc is the grpc.ServiceDesc for LCPDService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LCPDService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lcpd.v1.LCPDService",
	HandlerType: (*LCPDServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListLCPPeers",
			Handler:    _LCPDService_ListLCPPeers_Handler,
		},
		{
			MethodName: "GetLocalInfo",
			Handler:    _LCPDService_GetLocalInfo_Handler,
		},
		{
			MethodName: "RequestQuote",
			Handler:    _LCPDService_RequestQuote_Handler,
		},
		{
			MethodName: "AcceptAndExecute",
			Handler:    _LCPDService_AcceptAndExecute_Handler,
		},
		{
			MethodName: "CancelJob",
			Handler:    _LCPDService_CancelJob_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lcpd/v1/lcpd.proto",
}
