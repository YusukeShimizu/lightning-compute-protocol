// Code generated by protoc-gen-cobra. DO NOT EDIT.

package lcpdv1

import (
	client "github.com/NathanBaulch/protoc-gen-cobra/client"
	flag "github.com/NathanBaulch/protoc-gen-cobra/flag"
	iocodec "github.com/NathanBaulch/protoc-gen-cobra/iocodec"
	cobra "github.com/spf13/cobra"
	grpc "google.golang.org/grpc"
	proto "google.golang.org/protobuf/proto"
	io "io"
)

func LCPDServiceClientCommand(options ...client.Option) *cobra.Command {
	cfg := client.NewConfig(options...)
	cmd := &cobra.Command{
		Use:   cfg.CommandNamer("LCPDService"),
		Short: "LCPDService service client",
		Long:  "LCPDService exposes peer discovery and the core LCP quote→pay→execute flow.\n\n Error model:\n RPC failures are returned as canonical gRPC status codes (e.g. INVALID_ARGUMENT,\n NOT_FOUND, FAILED_PRECONDITION, UNAVAILABLE). Message-level validation failures\n are expected to return INVALID_ARGUMENT.",
	}
	cfg.BindFlags(cmd.PersistentFlags())
	cmd.AddCommand(
		_LCPDServiceListLCPPeersCommand(cfg),
		_LCPDServiceGetLocalInfoCommand(cfg),
		_LCPDServiceRequestQuoteCommand(cfg),
		_LCPDServiceAcceptAndExecuteCommand(cfg),
		_LCPDServiceAcceptAndExecuteStreamCommand(cfg),
		_LCPDServiceCancelJobCommand(cfg),
	)
	return cmd
}

func _LCPDServiceListLCPPeersCommand(cfg *client.Config) *cobra.Command {
	req := &ListLCPPeersRequest{}

	cmd := &cobra.Command{
		Use:   cfg.CommandNamer("ListLCPPeers"),
		Short: "ListLCPPeers RPC client",
		Long:  "ListLCPPeers lists currently connected peers that support LCP.\n\n Errors:\n - UNAVAILABLE: The daemon cannot reach the underlying Lightning node (e.g. lnd),\n   or peer tracking is temporarily unavailable.\n   Impact: No peer list is returned.\n - INTERNAL: Unexpected server error.\n   Impact: No peer list is returned.",
		RunE: func(cmd *cobra.Command, args []string) error {
			if cfg.UseEnvVars {
				if err := flag.SetFlagsFromEnv(cmd.Parent().PersistentFlags(), true, cfg.EnvVarNamer, cfg.EnvVarPrefix, "LCPDService"); err != nil {
					return err
				}
				if err := flag.SetFlagsFromEnv(cmd.PersistentFlags(), false, cfg.EnvVarNamer, cfg.EnvVarPrefix, "LCPDService", "ListLCPPeers"); err != nil {
					return err
				}
			}
			return client.RoundTrip(cmd.Context(), cfg, func(cc grpc.ClientConnInterface, in iocodec.Decoder, out iocodec.Encoder) error {
				cli := NewLCPDServiceClient(cc)
				v := &ListLCPPeersRequest{}

				if err := in(v); err != nil {
					return err
				}
				proto.Merge(v, req)

				res, err := cli.ListLCPPeers(cmd.Context(), v)

				if err != nil {
					return err
				}

				return out(res)

			})
		},
	}

	return cmd
}

func _LCPDServiceGetLocalInfoCommand(cfg *client.Config) *cobra.Command {
	req := &GetLocalInfoRequest{}

	cmd := &cobra.Command{
		Use:   cfg.CommandNamer("GetLocalInfo"),
		Short: "GetLocalInfo RPC client",
		Long:  "GetLocalInfo gets the local node's LCP information and manifest.\n\n Errors:\n - UNAVAILABLE: The daemon cannot reach the underlying Lightning node (e.g. lnd),\n   so local identity/capabilities cannot be fetched.\n   Impact: No local info is returned.\n - INTERNAL: Unexpected server error.\n   Impact: No local info is returned.",
		RunE: func(cmd *cobra.Command, args []string) error {
			if cfg.UseEnvVars {
				if err := flag.SetFlagsFromEnv(cmd.Parent().PersistentFlags(), true, cfg.EnvVarNamer, cfg.EnvVarPrefix, "LCPDService"); err != nil {
					return err
				}
				if err := flag.SetFlagsFromEnv(cmd.PersistentFlags(), false, cfg.EnvVarNamer, cfg.EnvVarPrefix, "LCPDService", "GetLocalInfo"); err != nil {
					return err
				}
			}
			return client.RoundTrip(cmd.Context(), cfg, func(cc grpc.ClientConnInterface, in iocodec.Decoder, out iocodec.Encoder) error {
				cli := NewLCPDServiceClient(cc)
				v := &GetLocalInfoRequest{}

				if err := in(v); err != nil {
					return err
				}
				proto.Merge(v, req)

				res, err := cli.GetLocalInfo(cmd.Context(), v)

				if err != nil {
					return err
				}

				return out(res)

			})
		},
	}

	return cmd
}

func _LCPDServiceRequestQuoteCommand(cfg *client.Config) *cobra.Command {
	req := &RequestQuoteRequest{}

	cmd := &cobra.Command{
		Use:   cfg.CommandNamer("RequestQuote"),
		Short: "RequestQuote RPC client",
		Long:  "RequestQuote sends an `lcp_call` and a request stream to a specific peer.\n\n On success, it returns the provider's `lcp_quote` as `Quote`,\n including a BOLT11 invoice whose `description_hash` MUST equal `terms_hash`\n (invoice swapping defense).\n Errors:\n - INVALID_ARGUMENT: Request validation failed (e.g. `peer_id` format, missing\n   `call`, or invalid call spec).\n   Impact: No wire message is sent to the peer.\n - NOT_FOUND: The target peer is unknown to the daemon.\n   Impact: No wire message is sent to the peer.\n - FAILED_PRECONDITION: The target peer is not connected and ready for LCP\n   (e.g. no manifest observed, protocol mismatch, or LCP disabled).\n   Impact: No quote is returned; clients may retry after resolving the condition.\n - RESOURCE_EXHAUSTED: The request would exceed a payload/size limit (local\n   or remote `max_payload_bytes`), or the daemon refuses due to local policy.\n   Impact: No quote is returned.\n - DEADLINE_EXCEEDED: The peer did not respond before the client/server deadline.\n   Impact: Quote outcome is unknown to the caller; retry MAY result in a new\n   `call_id` and a different invoice unless the implementation provides idempotency.\n - UNAVAILABLE: Transient transport failure sending/receiving peer messages.\n   Impact: Quote outcome is unknown; safe retries depend on idempotency.",
		RunE: func(cmd *cobra.Command, args []string) error {
			if cfg.UseEnvVars {
				if err := flag.SetFlagsFromEnv(cmd.Parent().PersistentFlags(), true, cfg.EnvVarNamer, cfg.EnvVarPrefix, "LCPDService"); err != nil {
					return err
				}
				if err := flag.SetFlagsFromEnv(cmd.PersistentFlags(), false, cfg.EnvVarNamer, cfg.EnvVarPrefix, "LCPDService", "RequestQuote"); err != nil {
					return err
				}
			}
			return client.RoundTrip(cmd.Context(), cfg, func(cc grpc.ClientConnInterface, in iocodec.Decoder, out iocodec.Encoder) error {
				cli := NewLCPDServiceClient(cc)
				v := &RequestQuoteRequest{}

				if err := in(v); err != nil {
					return err
				}
				proto.Merge(v, req)

				res, err := cli.RequestQuote(cmd.Context(), v)

				if err != nil {
					return err
				}

				return out(res)

			})
		},
	}

	cmd.PersistentFlags().StringVar(&req.PeerId, cfg.FlagNamer("PeerId"), "", "The target peer's Node ID (Pubkey).")
	_Call := &CallSpec{}
	cmd.PersistentFlags().StringVar(&_Call.Method, cfg.FlagNamer("Call Method"), "", "Method name (wire mapping: `lcp_call.method`).")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Call Method"), func() { req.Call = _Call })
	flag.BytesBase64Var(cmd.PersistentFlags(), &_Call.Params, cfg.FlagNamer("Call Params"), "Opaque method params bytes (wire mapping: `lcp_call.params`).\n For LCP v0.3, params are method-defined opaque bytes (often a TLV stream).")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Call Params"), func() { req.Call = _Call })
	cmd.PersistentFlags().StringVar(&_Call.ParamsContentType, cfg.FlagNamer("Call ParamsContentType"), "", "Optional params content type hint (wire mapping: `lcp_call.params_content_type`).")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Call ParamsContentType"), func() { req.Call = _Call })
	flag.BytesBase64Var(cmd.PersistentFlags(), &_Call.RequestBytes, cfg.FlagNamer("Call RequestBytes"), "Decoded request bytes to send in the request stream.")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Call RequestBytes"), func() { req.Call = _Call })
	cmd.PersistentFlags().StringVar(&_Call.RequestContentType, cfg.FlagNamer("Call RequestContentType"), "", "Request stream content type (wire mapping: `lcp_stream_begin.content_type`).")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Call RequestContentType"), func() { req.Call = _Call })
	cmd.PersistentFlags().StringVar(&_Call.RequestContentEncoding, cfg.FlagNamer("Call RequestContentEncoding"), "", "Request stream content encoding (wire mapping: `lcp_stream_begin.content_encoding`).")
	flag.WithPostSetHook(cmd.PersistentFlags(), cfg.FlagNamer("Call RequestContentEncoding"), func() { req.Call = _Call })

	return cmd
}

func _LCPDServiceAcceptAndExecuteCommand(cfg *client.Config) *cobra.Command {
	req := &AcceptAndExecuteRequest{}

	cmd := &cobra.Command{
		Use:   cfg.CommandNamer("AcceptAndExecute"),
		Short: "AcceptAndExecute RPC client",
		Long:  "AcceptAndExecute pays the invoice associated with the quote and waits for\n the terminal `lcp_complete` and (when available) the validated response stream.\n\n This is a blocking call. Clients SHOULD set a deadline and MAY cancel via\n context cancellation (gRPC) or `CancelJob`.\n\n Errors:\n - INVALID_ARGUMENT: Request validation failed (e.g. `peer_id`/`call_id` format),\n   or `pay_invoice=false`.\n   Impact: No payment attempt is made and no execution is started.\n - NOT_FOUND: The daemon has no known quote/payment data for the given `call_id`.\n   Impact: No payment attempt is made.\n - FAILED_PRECONDITION: The quote is expired, the job is not executable, or the\n   daemon refuses to pay/execute due to local policy.\n   Impact: No execution is started.\n - UNAVAILABLE: Transient failure interacting with the Lightning node for payment,\n   or transient peer messaging failure for waiting on the result.\n   Impact: The job/payment outcome may be unknown; callers SHOULD treat retries\n   with caution because a payment could have succeeded while the result wait failed.\n - DEADLINE_EXCEEDED: The result did not arrive before the deadline.\n   Impact: The job may still complete and deliver a result later; callers SHOULD\n   avoid blindly retrying payment logic.\n - INTERNAL: Unexpected server error.\n   Impact: Outcome may be unknown if failure happened after payment settlement.",
		RunE: func(cmd *cobra.Command, args []string) error {
			if cfg.UseEnvVars {
				if err := flag.SetFlagsFromEnv(cmd.Parent().PersistentFlags(), true, cfg.EnvVarNamer, cfg.EnvVarPrefix, "LCPDService"); err != nil {
					return err
				}
				if err := flag.SetFlagsFromEnv(cmd.PersistentFlags(), false, cfg.EnvVarNamer, cfg.EnvVarPrefix, "LCPDService", "AcceptAndExecute"); err != nil {
					return err
				}
			}
			return client.RoundTrip(cmd.Context(), cfg, func(cc grpc.ClientConnInterface, in iocodec.Decoder, out iocodec.Encoder) error {
				cli := NewLCPDServiceClient(cc)
				v := &AcceptAndExecuteRequest{}

				if err := in(v); err != nil {
					return err
				}
				proto.Merge(v, req)

				res, err := cli.AcceptAndExecute(cmd.Context(), v)

				if err != nil {
					return err
				}

				return out(res)

			})
		},
	}

	cmd.PersistentFlags().StringVar(&req.PeerId, cfg.FlagNamer("PeerId"), "", "The target peer's Node ID.")
	flag.BytesBase64Var(cmd.PersistentFlags(), &req.CallId, cfg.FlagNamer("CallId"), "The call_id to execute (must match a previously received Quote).")
	cmd.PersistentFlags().BoolVar(&req.PayInvoice, cfg.FlagNamer("PayInvoice"), false, "Authorization to pay the invoice.")

	return cmd
}

func _LCPDServiceAcceptAndExecuteStreamCommand(cfg *client.Config) *cobra.Command {
	req := &AcceptAndExecuteStreamRequest{}

	cmd := &cobra.Command{
		Use:   cfg.CommandNamer("AcceptAndExecuteStream"),
		Short: "AcceptAndExecuteStream RPC client",
		Long:  "AcceptAndExecuteStream pays the invoice associated with the quote and streams\n the decoded response stream bytes as they arrive.\n\n The stream ends with a terminal `Complete` event that indicates the final job\n status and (when available) the validated stream metadata (hash/len).\n\n Errors follow the same model as `AcceptAndExecute`, but note that streaming\n responses may have already delivered partial bytes before an error is\n detected (for example, checksum validation failure at stream end).",
		RunE: func(cmd *cobra.Command, args []string) error {
			if cfg.UseEnvVars {
				if err := flag.SetFlagsFromEnv(cmd.Parent().PersistentFlags(), true, cfg.EnvVarNamer, cfg.EnvVarPrefix, "LCPDService"); err != nil {
					return err
				}
				if err := flag.SetFlagsFromEnv(cmd.PersistentFlags(), false, cfg.EnvVarNamer, cfg.EnvVarPrefix, "LCPDService", "AcceptAndExecuteStream"); err != nil {
					return err
				}
			}
			return client.RoundTrip(cmd.Context(), cfg, func(cc grpc.ClientConnInterface, in iocodec.Decoder, out iocodec.Encoder) error {
				cli := NewLCPDServiceClient(cc)
				v := &AcceptAndExecuteStreamRequest{}

				if err := in(v); err != nil {
					return err
				}
				proto.Merge(v, req)

				stm, err := cli.AcceptAndExecuteStream(cmd.Context(), v)

				if err != nil {
					return err
				}

				for {
					res, err := stm.Recv()
					if err != nil {
						if err == io.EOF {
							break
						}
						return err
					}
					if err = out(res); err != nil {
						return err
					}
				}
				return nil

			})
		},
	}

	cmd.PersistentFlags().StringVar(&req.PeerId, cfg.FlagNamer("PeerId"), "", "The target peer's Node ID.")
	flag.BytesBase64Var(cmd.PersistentFlags(), &req.CallId, cfg.FlagNamer("CallId"), "The call_id to execute (must match a previously received Quote).")
	cmd.PersistentFlags().BoolVar(&req.PayInvoice, cfg.FlagNamer("PayInvoice"), false, "Authorization to pay the invoice.")

	return cmd
}

func _LCPDServiceCancelJobCommand(cfg *client.Config) *cobra.Command {
	req := &CancelJobRequest{}

	cmd := &cobra.Command{
		Use:   cfg.CommandNamer("CancelJob"),
		Short: "CancelJob RPC client",
		Long:  "CancelJob sends an `lcp_cancel` message to the provider.\n\n Cancellation is best-effort: the provider may have already completed the job.\n\n Errors:\n - INVALID_ARGUMENT: Request validation failed (e.g. `peer_id`/`call_id` format).\n   Impact: No cancel message is sent.\n - NOT_FOUND: The target peer is unknown to the daemon.\n   Impact: No cancel message is sent.\n - FAILED_PRECONDITION: The daemon cannot currently send peer messages to the\n   target peer (e.g. not connected).\n   Impact: No cancel message is sent.\n - UNAVAILABLE: Transient transport failure sending the cancel message.\n   Impact: Unknown whether the provider received the cancel; retries are generally safe.\n - DEADLINE_EXCEEDED: The cancel attempt did not complete before the deadline.\n   Impact: Unknown whether the provider received the cancel; retries are generally safe.\n - INTERNAL: Unexpected server error.\n   Impact: Unknown whether the provider received the cancel.",
		RunE: func(cmd *cobra.Command, args []string) error {
			if cfg.UseEnvVars {
				if err := flag.SetFlagsFromEnv(cmd.Parent().PersistentFlags(), true, cfg.EnvVarNamer, cfg.EnvVarPrefix, "LCPDService"); err != nil {
					return err
				}
				if err := flag.SetFlagsFromEnv(cmd.PersistentFlags(), false, cfg.EnvVarNamer, cfg.EnvVarPrefix, "LCPDService", "CancelJob"); err != nil {
					return err
				}
			}
			return client.RoundTrip(cmd.Context(), cfg, func(cc grpc.ClientConnInterface, in iocodec.Decoder, out iocodec.Encoder) error {
				cli := NewLCPDServiceClient(cc)
				v := &CancelJobRequest{}

				if err := in(v); err != nil {
					return err
				}
				proto.Merge(v, req)

				res, err := cli.CancelJob(cmd.Context(), v)

				if err != nil {
					return err
				}

				return out(res)

			})
		},
	}

	cmd.PersistentFlags().StringVar(&req.PeerId, cfg.FlagNamer("PeerId"), "", "The target peer's Node ID.")
	flag.BytesBase64Var(cmd.PersistentFlags(), &req.CallId, cfg.FlagNamer("CallId"), "The call_id to cancel.")
	cmd.PersistentFlags().StringVar(&req.Reason, cfg.FlagNamer("Reason"), "", "Optional human-readable cancellation reason.")

	return cmd
}
